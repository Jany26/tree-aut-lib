import copy

from tree_automata import TTreeAut, TTransition


# Creates a tree automaton, that only generates trees which can be generated by
#  both its input automatons.
def tree_aut_intersection(ta1: TTreeAut, ta2: TTreeAut, verbose=False) -> TTreeAut:
    # Helper function, creates a pair key, [edgeInfo] for TAinteresction()
    #  based on the two keys and two edges from input.
    #  If possible, adds a new transition into the result dictionary
    counter = 0

    def handle_intersection_edge(k1: str, e1: list, k2: str, e2: list, result: TTreeAut, state: str):
        new_key = f"({k1},{k2})"  # merge transition keys
        new_state = f"({e1.src},{e2.src})"  # merge source state names
        # e.g. states 'q1' and 'q2' create '(q1, q2)'
        new_edge = copy.deepcopy(e1.info)  # new edge with same info
        # merged children
        new_children = [f"({e1.children[i]},{e2.children[i]})" for i in range(len(e1.children))]
        if verbose:
            print("{:<60} {:<40} {:<40}".format(f"{counter}) {state}"[:60], f"{k1}"[:40], f"{k2}"[:40]))

        if state not in result.transitions:
            result.transitions[state] = {}
        for child in new_children:
            if child not in result.transitions:
                result.transitions[child] = {}
        # add transition to transitions in a state dictionary
        # if verbose: print(new_key)
        result.transitions[state][new_key] = TTransition(new_state, new_edge, new_children)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # NOTE: consider how to handle not-matching ports
    # label1 = transition1.info.label
    # label2 = transition2.info.label
    # if ((label1.startswith("Port")
    #     and label2.startswith("Port")
    #     and label1 != label2)):
    #     do_whatever()
    #     pass

    # NOTE: consider port adding (differentiating ports maybe by a counter)
    # if transition1.info.startswith("Port"):
    #     new_transition.append("Port")
    # else:
    #     new_transition.append(transition1.info)

    if ta2 is None:
        return ta1
    if ta1 is None:
        return ta2

    result = TTreeAut([], {}, f"int({ta1.name},{ta2.name})")
    for s1, edges1 in ta1.transitions.items():
        for s2, edges2 in ta2.transitions.items():
            new_state = f"({s1},{s2})"
            if s1 in ta1.roots and s2 in ta2.roots:
                result.roots.append(new_state)
            for k1, e1 in edges1.items():  # key1, edge1
                for k2, e2 in edges2.items():  # key2, edge2
                    if len(e1.children) != len(e2.children):  # arity consistency
                        continue
                    if e1.info.label != e2.info.label:  # symbol consistency
                        continue
                    counter += 1
                    handle_intersection_edge(k1, e1, k2, e2, result, new_state)

    result.port_arity = result.get_port_arity()
    result.name = f"intersection({ta1.name},{ta2.name})"
    return result
