# ta_functions.py
# Basic functions for working with tree automata (from taLib.py)
# Implementation of tree automata for article about automata-based BDDs
# Author: Jany26  (Jan Matufka)  <xmatuf00@stud.fit.vutbr.cz>

from ta_classes import *
from utils import *

from itertools import product
from typing import Tuple

import copy

# All operations for tree automata (TA) implemented in this module:
# - match(TA, tree) checks whether a tree can be generated by a tree automaton
# - determinize(TA) creates a deterministic (and complete) TA from a NTA
# - union(TA1, TA2)
# - intersection(TA1, TA2)
# - complement(TA)
# - removeUselessStates(TA) removes unreachable states from a TA
# - nonEmptinessCheck(TA) checks whether a language of TA is non-empty
# - generateWitness(TA) creates an example of a tree generated by the TA

# MAYBE TODO
# - compareTwoBoxes(TA1, TA2) - isomoprhism check

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# SUBFUNCTIONS / HELPER FUNCTIONS
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Helper function for bottom-up tree parsing
# - (determinization, reachability, nonEmptiness)


# Creates all possible variations (with repetition) of items
#  from list of "parents" of a given length ("size"),
#  such that the variation (stored in a list)
#  contains the "state" item at least once
#  note: assumes, that the "state" is in parents "list"
def generatePossibleChildren(state: str, parents: list, size: int) -> list:
    possibilites = product(parents, repeat=size)
    result = [list(k) for k in possibilites if state in k]
    # for k in possibilites:
    #     if state in k:
    #         result.append(list(k))
    return result

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Non emptiness check (+ witness generation) helper functions


# # Helper function for generating tree starting from a specified node
#   uses a dictionary of transitions (only 1 needed for each state)
def generateWitnessTree(edgeDict: dict, root: str) -> TTreeNode:
    if (type(edgeDict) is None or type(root) is None):
        return None
    if len(edgeDict[root].children) == 0:
        return TTreeNode(f"({edgeDict[root].info.label};{root})")
    else:
        tempNode = TTreeNode(f"({edgeDict[root].info.label};{root})")
        for i in edgeDict[root].children:
            tempChild = generateWitnessTree(edgeDict, i)
            tempNode.connectChild(tempChild)
        return tempNode


# # Helper function for generating a string that represents a tree, top-down,
#   uses dictionary of transitions (only 1 needed for each state)
def generateWitnessString(edgeDict: dict, root: str) -> str:
    if len(edgeDict[root].children) == 0:
        return str(edgeDict[root].info.label)
    else:
        parentString = str(edgeDict[root].info.label) + "["
        for i in range(len(edgeDict[root].children)):
            childString = generateWitnessString(edgeDict, edgeDict[root].children[i])
            parentString += childString
            if i < len(edgeDict[root].children) - 1:
                parentString += ";"
        return parentString + "]"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# BASIC OPERATIONS ON TREE AUTOMATA
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# # Logical equivalent to function accept(DFA, string)
#   works recursively, as all children from array have to be matched
def matchTreeTD(ta: TTreeAut, root: TTreeNode) -> bool:

    # Helper function for matchTreeTD  - - - - - - - - - - - - - - - - - - - -

    def matchTopDown(ta: TTreeAut, node: TTreeNode, state: str) -> bool:
        descendantTuples = []

        for stateName, edge in ta.transitions.items():
            for data in edge.values():
                if stateName == state and node.value == data.info.label:
                    descendantTuples.append(data.children)

        for tuple in descendantTuples:
            b = True
            # when tree unexpected amount children than expected
            if len(tuple) != len(node.children):
                break
            for i in range(len(tuple)):
                # recursive matching for all children
                b = matchTopDown(ta, node.children[i], tuple[i])
                if not b:
                    break
            if b:
                return True
        return False

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    for rootPtr in ta.rootStates:
        if matchTopDown(ta, root, rootPtr) is True:
            return True
    return False

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Logical equivalent to function accept(DFA, string)
#  works recursively, but starts the matching process from the leaves
#  instead of starting from the root
def matchTreeBU(ta: TTreeAut, root: TTreeNode) -> bool:
    # Helper function for matchTreeBU  - - - - - - - - - - - - - - - - - - - -
    def matchBottomUp(ta: TTreeAut, root: TTreeNode) -> list:
        result = []
        if len(root.children) == 0:
            for stateName, edge in ta.transitions.items():
                for data in edge.values():
                    if (
                        data.info.label == root.value  # or symbol
                        and len(data.children) == 0
                        and stateName not in result
                    ):
                        result.append(stateName)
            return result

        else:
            childrenSymbols = []
            for i in range(len(root.children)):
                childrenSymbols.append(matchBottomUp(ta, root.children[i]))
            for stateName, edge in ta.transitions.items():
                for data in edge.values():
                    if data.info.label == root.value:  # or symbol
                        x = True
                        for i in range(len(data.children)):
                            if data.children[i] not in childrenSymbols[i]:
                                x = False
                                break
                        if x:
                            result.append(stateName)
            return result
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    result = matchBottomUp(ta, root)
    temp = []
    for value in result:
        if value in ta.rootStates:
            temp.append(value)
    return len(temp) != 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Helper functions for BU-determinization - - - - - - - - - - - - - - - - -


# creates a string (state name) from list of states -- e.g. '{a,b,c}'
def detCreateName(stateList: list) -> str:
    myList = stateNameSort(stateList)
    return "{" + ",".join(myList) + "}"


# Create a "reverse" transition dictionary, in which parents of specified edges
#  can be found -- important for bottom-up algorithms (determinization).
#  Lookup goes like this:
#    symbol -> children -> then the parent/source state is found
#  Note: list of children is "stringified"
# {symbol : {"children" : [parents]}}
def detCreateLookupDict(ta: TTreeAut, alphabet) -> dict:
    result = {symbol: {} for symbol in alphabet}
    for edges in ta.transitions.values():
        for edge in edges.values():
            symbol = edge.info.label

            if str(edge.children) not in result[symbol]:
                result[symbol][str(edge.children)] = []

            if edge.src not in result[symbol][str(edge.children)]:
                result[symbol][str(edge.children)].append(edge.src)
    return result


# Creates all needed permutations for determinization consideration,
#  which contain the specified 'state' and other states are filled with states
#  from the 'stateList' (to get the specific permutation 'size').
def detGenerateTuples(stateList: list, state: list, size: int) -> list:
    cartProd = product(stateList, repeat=size)
    return [list(i) for i in cartProd if state in i]


# Creates a list of output states based on the symbols.
def detOutEdges(outEdges: list, doneEdges, alphabet):
    result = []
    for symbol in outEdges:
        doneEdges.append([outEdges[symbol], symbol, []])
        result.append(outEdges[symbol])

    for symbol in alphabet:
        if symbol not in outEdges and alphabet[symbol] == 0:
            doneEdges.append([[], symbol, []])
            if [] not in result:
                result.append([])
    return result


# Finds all possible source states (parents) for a set of given
#  macrostates (lists of states) - parameter 'tuple'.
#  For this, a lookup dictionary is created at the start of determinization.
#  Function tries to perform a bottom-up step:
#  trying to find a feasible transition from a given children tuple
def detChildHandle(tuple: list, lookup: dict) -> list:
    children = [list(i) for i in product(*tuple)]
    result = []
    for i in children:
        if str(i) not in lookup:
            continue
        for j in lookup[str(i)]:
            if j in result:
                continue
            result.append(j)
    result.sort()
    return result


# This function creates a transition dict for the resulting tree automaton,
#  based on the ad-hoc data notes created during determinization.
#  The result is in the right format needed for TTreeAut class.
def detCreateRelation(edgeList: list, alphabet: dict) -> dict:
    edgeDict = {}
    # print(f"> ALPHABET\n{alphabet}")
    for edge in edgeList:
        # print(f"  > EDGE = {edge}")
        source = detCreateName(edge[0])
        symbol = TEdge(edge[1], [None] * alphabet[str(edge[1])], "")
        # print(f"    > SRC = {source}")
        # print(f"    > SYM = {edge[1]}")
        # print(f"    > CHI = {edge[2]}")
        children = [detCreateName(i) for i in edge[2]]
        key = f"{source}-{edge[1]}->({children})"
        if source not in edgeDict:
            edgeDict[source] = {}
        edgeDict[source][key] = TTransition(source, symbol, children)
    return edgeDict


def detCreateRoots(doneStates: list, roots: list) -> list:
    result = set()
    for doneSet in doneStates:
        for root in roots:
            if root in doneSet:
                result.add(detCreateName(doneSet))
    return list(result)


# Creates a deterministic and complete version of the "ta"
#  tree automaton with regards to the "alphabet"
#  alphabet is a dictionary -> key = "symbol", value = arity (integer)
#  doneStates = list of macrostates (macrostate = list of states/strings)
#  doneTransitions = dictionary of transitions,
#  key is just some string created from doneStates by a function
#       - each key references a list/dict of all possible transitions
#  the transitions themselves look like this:
#       [ parentMacroState, symbol, childMacroStateList ]
#       - parentMacroState = list of states
#       - symbol =
#       - childMacroStateList = list of lists of states
#           - from which the states in parentMacroState can be reached
#             through an edge labeled with the symbol
#
#  * IMPORTANT NOTE
#     = doneStates and doneTransitions are just placeholder structures
#       - in the final automaton the macroStates
#         (list/set of states) will be represented by a string
#       - this string is created using makeNameFromSet() function
def treeAutDeterminization(ta: TTreeAut,
                           alphabet: dict,
                           verbose=False) -> TTreeAut:

    parentLookup = detCreateLookupDict(ta, alphabet)
    doneTuples = {symbol: {} for symbol in alphabet}
    doneEdges = []
    doneSet = detOutEdges(ta.getOutputEdges(), doneEdges, alphabet)
    workSet = copy.deepcopy(doneSet)
    if verbose:
        # print("workset   = {workSet}")
        # print("doneset   = {doneSet}")
        # print("doneedges = {doneEdges}")
        print("{:<60} {:<20} {:<60} {:<5} {:<5}".format(
            "currentState", "symbol", "children", "work", "done"
        ))
        print("-" * 160)
        counter = 0
    while workSet != []:
        state = workSet[0]
        workSet.remove(state)
        doneSet.append(state)
        for symbol, arity in alphabet.items():
            lookup = parentLookup[symbol]
            if lookup == {}:
                # TODO: HANDLE UNUSED SYMBOL
                pass
            combinations = detGenerateTuples(doneSet, state, arity)
            for tuple in combinations:
                # print(combinations)
                if str(tuple) in doneTuples[symbol]:
                    continue
                if verbose:
                    counter += 1
                    print("{:<60} {:<20} {:<60} {:<5} {:<5}".format(
                        f"{counter}) {state}"[:60],
                        symbol[:20],
                        str(tuple)[:60],
                        len(workSet),
                        len(doneSet)
                    ))
                parents = detChildHandle(tuple, lookup)
                doneTuples[symbol][str(tuple)] = parents
                if parents not in workSet:
                    workSet.append(parents)
                doneEdges.append([parents, symbol, tuple])

    newRoots = detCreateRoots(doneSet, ta.rootStates)
    newEdges = detCreateRelation(doneEdges, alphabet)
    result = TTreeAut(newRoots, newEdges, f"determinized({ta.name})")
    result.portArity = result.getPortArity()

    if verbose:
        print(f"determinization of {ta.name} done")

    return result
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Creates a tree automaton, that generates trees which can be generated by
#  at least one of its two input automatons.
#
#  just merging transition dictionaries and set of rootstates
#  before merging, name resolution is needed for states with the same name
def treeAutUnion(ta1: TTreeAut, ta2: TTreeAut) -> TTreeAut:
    result = copy.deepcopy(ta2)
    result.name = f"union({ta1.name},{ta2.name})"

    # remove name collisions by renaming states in a new automaton
    for stateName in ta1.transitions:
        if stateName in result.transitions:
            result.renameState(stateName, str(stateName) + "_new")

    # merge the two automata
    result.transitions = {**result.transitions, **ta1.transitions}
    result.rootStates = result.rootStates + ta1.rootStates
    result.portArity = result.getPortArity()
    return result


# Creates a tree automaton, that only generates trees which can be generated by
#  both its input automatons.
def treeAutIntersection(ta1: TTreeAut,
                        ta2: TTreeAut,
                        verbose=False) -> TTreeAut:
    # Helper function, creates a pair key, [edgeInfo] for TAinteresction()
    #  based on the two keys and two edges from input.
    #  If possible, adds a new transition into the result dictionary
    counter = 0

    def handleIntersectionEdge(k1: str, e1: list, k2: str, e2: list,
                               result: TTreeAut, state: str):
        newKey = f"({k1},{k2})"  # merge transition keys
        newState = f"({e1.src},{e2.src})"  # merge source state names
        # e.g. states 'q1' and 'q2' create '(q1, q2)'
        newEdge = copy.deepcopy(e1.info)  # new edge with same info
        # merged children
        newChildren = [f"({e1.children[i]},{e2.children[i]})" for i in range(len(e1.children))]
        if verbose:
            print("{:<60} {:<40} {:<40}".format(
                f"{counter}) {state}"[:60],
                f"{k1}"[:40],
                f"{k2}"[:40]
            ))

        if state not in result.transitions:
            result.transitions[state] = {}
        # add transition to transitions in a state dictionary
        # if verbose: print(newKey)
        result.transitions[state][newKey] = TTransition(newState, newEdge, newChildren)
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # NOTE: consider how to handle not-matching ports
    # label1 = transition1.info.label
    # label2 = transition2.info.label
    # if ((label1.startswith("Port")
    #     and label2.startswith("Port")
    #     and label1 != label2)):
    #     doWhatever()
    #     pass

    # NOTE: consider port adding (differentiating ports maybe by a counter)
    # if transition1.info.startswith("Port"):
    #     newTransition.append("Port")
    # else:
    #     newTransition.append(transition1.info)

    if ta2 is None:
        return ta1
    if ta1 is None:
        return ta2

    result = TTreeAut([], {}, f"int({ta1.name},{ta2.name})")
    for stateName1, edgeDict1 in ta1.transitions.items():
        for stateName2, edgeDict2 in ta2.transitions.items():
            newStateName = f"({stateName1},{stateName2})"
            if stateName1 in ta1.rootStates and stateName2 in ta2.rootStates:
                result.rootStates.append(newStateName)
            for k1, e1 in edgeDict1.items():  # key1, edge1
                for k2, e2 in edgeDict2.items():  # key2, edge2
                    if len(e1.children) != len(e2.children):  # arity consistency
                        continue
                    if e1.info.label != e2.info.label:  # symbol consistency
                        continue
                    counter += 1
                    handleIntersectionEdge(k1, e1, k2, e2,
                                           result, newStateName)

    result.portArity = result.getPortArity()
    result.name = f"intersection({ta1.name},{ta2.name})"
    return result


# creates a tree automaton that can only generate trees,
#  that can not be generated by the input TA
#  - uses determinization and completion of the TA beforehand
def treeAutComplement(ta: TTreeAut, alphabet: dict, verbose=False) -> TTreeAut:
    result = treeAutDeterminization(ta, alphabet, verbose)
    roots = [i for i in result.getStates() if i not in result.rootStates]
    result.rootStates = roots
    result.name = f"complement({ta.name})"
    return result


# needed for co-occurence relation
def treeAutProduct(ta1: TTreeAut, ta2: TTreeAut) -> TTreeAut:

    def makeNameFromList(stateList: list) -> str:
        result = "("
        for i in range(len(stateList)):
            result += stateList[i]
            if i < len(stateList) - 1:
                result += ","
        result += ")"
        return result

    def createRoots(ta1: TTreeAut, ta2: TTreeAut) -> list:
        rootsMerge = []
        rootsMerge.append(ta1.rootStates)
        rootsMerge.append(ta2.rootStates)
        roots = product(*rootsMerge)
        return [list(i) for i in roots]

    def productify(state1, state2, ta1, ta2, edgeDict, done):
        if [state1, state2] in done:
            return
        done.append([state1, state2])
        for edge1 in ta1.transitions[state1].values():
            for edge2 in ta2.transitions[state2].values():
                srcState = [edge1.src, edge2.src]
                symbol1 = edge1.info.label
                symbol2 = edge2.info.label
                if len(edge1.children) == 0 and len(edge2.children) == 0:
                    # handle output symbols
                    if symbol1 == symbol2 or symbol1.startswith("Port"):
                        edgeDict.append([srcState, symbol1, []])

                if symbol1 == symbol2 and len(edge1.children) > 0:
                    children = []
                    for i in range(len(edge1.children)):
                        children.append([edge1.children[i], edge2.children[i]])
                    edgeDict.append([srcState, symbol1, children])
                    for i in children:
                        if [i.src, i.info] not in done:
                            productify(i.src, i.info, ta1, ta2, edgeDict, done)

    def createProductRelation(edgeList: list, alphabet: dict) -> dict:
        edgeDict = {}
        for edge in edgeList:
            srcState = makeNameFromList(edge[0])
            if srcState not in edgeDict:
                edgeDict[srcState] = {}
            edgeObj = TEdge(edge[1], [None] * alphabet[edge[1]], "")
            children = [makeNameFromList(edge[2][i])
                        for i in range(len(edge[2]))]
            key = f"{srcState}-{edge[1]}-{children}"
            edgeDict[srcState][key] = [srcState, edgeObj, children]
        return edgeDict

    alphabet = {**ta1.getSymbolArityDict(), **ta2.getSymbolArityDict()}
    roots = createRoots(ta1, ta2)
    edgeList = []
    done = []
    for root in roots:
        productify(root[0], root[1], ta1, ta2, edgeList, done)

    newRoots = [makeNameFromList(i) for i in roots]
    edgeDict = createProductRelation(edgeList, alphabet)
    result = TTreeAut(newRoots, edgeDict, f"product({ta1.name},{ta2.name})", 0)
    result.portArity = result.getPortArity()

    return result

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Returns a "witness tree" if the tree automaton has non empty tree "language"
#  Witness tree is just an example of most trivial
#  trees generated by this automaton.
#  If the TA has empty language, a tuple (None, "") is returned
#  meaning the tree automaton can generate at least one tree
#  returns a trivial example of a tree
#  that can be generated by the tree automaton
#  and its string representation
#  if the language is empty, None and empty string is returned
def nonEmptyTD(ta: TTreeAut, verbose=False) -> Tuple[TTreeNode, str]:

    def nonEmptyTDinitFunc(ta: TTreeAut) -> Tuple[dict, dict]:
        edgeLookup = {}
        outDict = {}
        for outSymbol, stateList in ta.getOutputEdges().items():
            for state in stateList:
                if state in edgeLookup:
                    continue
                outDict[state] = True
                edgeLookup[state] = TTransition(state, TEdge(outSymbol, [], ""), [])

        return edgeLookup, outDict

    def debugOutput(outDict, edgeLookup):
        trueList = []
        falseList = []
        for state, value in outDict.items():
            trueList.append(state) if value else falseList.append(state)
        print(f"  TRUE -> {trueList}")
        print(f"  FALSE -> {falseList}")
        for state, edge in edgeLookup.items():
            print(f"  {state} -> {edge}")

    # Returns True if the state from a tree automaton
    #  can generate output (in finite amount of steps)
    #  uses top-down approach and thus backtracking,
    #  which requires a stack for remembering visited states
    #  as the tree is being parsed, edge lookup dictionary is being filled,
    #    - this dictionary is then used in witness generation
    #  * note: witness = example of a tree generated by the TA
    def outputSearchTD(ta: TTreeAut, state: str, visited: list,
                       outDict: dict, edgeLookup: dict, debug, total) -> bool:
        if (
            state in visited  # breaking endless recursion
            or state not in ta.transitions  # skipping if state has no entry
            or len(ta.transitions[state]) == 0  # or an empty entry
        ):
            # if debug: print("    > FALSE ... self-loop or invalid state")
            if debug:
                print("{:<40} {:<5} {:<30}".format(
                      f"{state}"[:40], f"SKIP", f""))
            return False

        if debug:
            print("{:<60} {:<120} {:<12}".format(
                f"state " + "-" * 54,
                f"callStack " + "-" * 108,
                f"done",
                f"function"
            ))
            print("{:<60} {:<120} {:<12}".format(
                f"{state}"[:60],
                f"{visited}"[:120],
                f"{len(outDict)}/{total}",
                f"neTD({ta.name})"
            ))

        for edge in ta.transitions[state].values():
            # skipping self-looping transitions
            if state in edge.children:
                continue
            outputReachable = True
            for child in edge.children:
                # checking if the state has been already visited
                # and we know if its OK
                if child in outDict:
                    if outDict[child]:
                        if debug:
                            print("{:<40} {:<5} {:<50}".format(
                                f"{state}"[:40],
                                f"TRUE",
                                f"direct | {state}"
                            ))
                        continue
                    else:
                        if debug:
                            print("{:<40} {:<5} {:<50}".format(
                                f"{state}"[:40],
                                f"FALSE",
                                f"direct | {state}"
                            ))
                        outputReachable = False
                        break
                # we dont know anything about the state =
                visited.append(state)
                # print(f"checking {child} -> ??? GOING DEEPER")
                outputReachable = outputSearchTD(ta, child, visited, outDict,
                                                 edgeLookup, debug, total)
                visited.remove(state)
                # skipping NOT OK transition
                if not outputReachable:
                    break

            # found an OK transition
            if outputReachable:
                if debug:
                    ln = len(visited)
                    print("{:<40} {:<5} {:<30}".format(
                        f"{state}"[:40],
                        f"TRUE",
                        f"recursion | {visited[ln-1]}" if ln > 0 else "root"[:30]
                    ))
                outDict[state] = True
                edgeLookup[state] = edge
                # callStack.remove(state)
                return True

        if debug:
            ln = len(visited)
            print("{:<40} {:<5} {:<30}".format(
                f"{state}"[:40],
                f"FALSE",
                f"recursion | {visited[ln-1]}" if ln > 0 else "root"[:30]
            ))
        outDict[state] = False

        # callStack.remove(state)
        return False

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    total = len(ta.getStates())  # for debug
    edgeLookup, outDict = nonEmptyTDinitFunc(ta)
    for root in ta.rootStates:
        if outputSearchTD(ta, root, [], outDict, edgeLookup, verbose, total):
            if verbose:
                print(f"{ta.name} has non-empty lang")
            witnessTree = generateWitnessTree(edgeLookup, root)
            witnessString = generateWitnessString(edgeLookup, root)
            return witnessTree, witnessString
    if verbose:
        print(f"{ta.name} has empty lang")
    return None, ""


# Bottom-up version of non empty language check
#  starts the mock tree generation from the leaves
#  same signature as top-down version
#  * leaves = states with output transitions
def nonEmptyBU(ta: TTreeAut, verbose=False) -> Tuple[TTreeNode, str]:
    if verbose:
        print("{:<60} {:<20} {:<20} {:<20} {:<20} {:<20}".format(
            "state", "symbol", "workset", "doneset", "allstates", "function"
        ))
        print("-" * 150)
        counter = 0

    # initialization phase (finding all output )
    workList = ta.getOutputStates()
    size = len(ta.getStates())
    done = {}
    doneSet = ta.getOutputStates()
    arityDict = ta.getSymbolArityDict()
    for state in workList:
        for edge in ta.transitions[state].values():
            if len(edge.children) == 0:
                done[state] = edge

    def doneEdgePrint(doneEdges: dict):
        result = []
        for i in doneEdges.values():
            result.append([i[0], i[1].label, i[2]])
        for j in result:
            print(j)
        print()

    # tree automaton bottom-up parsing phase
    while len(workList) != 0:
        state = workList[0]
        workList.remove(workList[0])
        if state not in doneSet:
            doneSet.append(state)
        if state in ta.rootStates:
            if verbose:
                print(f">> {ta.name} has non-empty lang")
            witnessTree = generateWitnessTree(done, state)
            witnessString = generateWitnessString(done, state)
            return witnessTree, witnessString
        for symbol in arityDict:
            arity = arityDict[symbol]
            if arity == 0:
                continue
            # tuples = all possible combinations of children lists with 'state'
            tuples = generatePossibleChildren(state, list(done), arity)
            if verbose:
                counter += 1
                print("{:<60} {:<20} {:<20} {:<20} {:<20} {:<20}".format(
                    f"{counter}) {state}",
                    f"{symbol}",
                    f"{len(workList)}",
                    f"{len(doneSet)}",
                    f"{size}",
                    f"neBU({ta.name})"
                ))
            for stateName, edgeDict in ta.transitions.items():
                for edge in edgeDict.values():
                    if (edge.info.label != symbol or edge.children not in tuples):
                        continue
                    if stateName not in done:
                        workList.append(stateName)
                        done[stateName] = edge

    if verbose:
        print(f">> {ta.name} has empty lang")
    return None, ""

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Searches the tree from bottom-up and from top-down,
#  removing unreachable states
def removeUselessStates(ta: TTreeAut) -> TTreeAut:
    workTA = copy.deepcopy(ta)
    reachableStatesBU = reachableBU(workTA)
    workTA.shrinkTA(reachableStatesBU)
    reachableStatesTD = reachableTD(workTA)
    workTA.shrinkTA(reachableStatesTD)
    return workTA


def getAllStateReachability(ta: TTreeAut, reflexive=False) -> dict:
    originalRoots = [i for i in ta.rootStates]
    result = {}
    for i in ta.getStates():
        ta.rootStates = [i]
        result[i] = set(reachableTD(ta, countItself=reflexive))
    ta.rootStates = [i for i in originalRoots]
    return result

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Generates a list of states reachable from the root states
def reachableTD(ta: TTreeAut, countItself=True) -> list:
    workList = [i for i in ta.rootStates]
    result = [i for i in ta.rootStates] if countItself is True else []

    while len(workList) > 0:
        state = workList.pop()
        if state not in ta.transitions:
            continue
        edgeDict = ta.transitions[state]
        for edge in edgeDict.values():
            for i in edge.children:
                if i not in result:
                    workList.append(i)
                    result.append(i)
    return result


# Generates a list of states reachable from the leaf states
def reachableBU(ta: TTreeAut) -> list:

    # this is needed for some longer children arrays
    # {'symbol1' : {'state1': 2, 'state2': 1}, 'symbol2': ...}
    def createStateArityDict(ta) -> dict:
        result = {}
        arities = ta.getSymbolArityDict()
        for symbol, arity in arities.items():
            if arity == 0:
                continue
            if symbol not in result:
                result[symbol] = {}
            for state in ta.getStates():
                if state not in result[symbol]:
                    result[symbol][state] = []

        for edge in iterateEdges(ta):
            childSet = set(edge.children)
            symbol = edge.info.label
            if arities[symbol] == 0:
                continue
            length = len(edge.children)
            for state in childSet:
                if length not in result[symbol][state]:
                    result[symbol][state].append(length)
        return result

    workList = ta.getOutputStates()
    result = ta.getOutputStates()
    arityDict = ta.getSymbolArityDict()
    extendedArityDict = createStateArityDict(ta)
    while len(workList) > 0:
        state = workList.pop()
        for symbol, arity in arityDict.items():
            if arity <= 0:
                continue

            arities = extendedArityDict[symbol][state]
            tuples = []
            for a in arities:
                tuples.extend(generatePossibleChildren(state, result, a))

            for stateName, edgeDict in ta.transitions.items():
                for edge in edgeDict.values():
                    if (
                        edge.info.label != symbol
                        or edge.children not in tuples
                    ):
                        continue
                    if stateName not in result:
                        workList.append(stateName)
                        result.append(stateName)  # similarly for dictionary
    return result


# One of the rule-checks for a well-defined tree automaton (box).
#  Implements bottom-up search and keeps information about all reachable port
#  combinations from a given state.
#
#  Each root state has to be able to reach a precise amount of ports, which is
#  given by TAs port-arity.
def portConsistencyCheck(ta: TTreeAut) -> bool:

    # Helper function, creates a list of sets,
    # which correspond to all possible reachable combinations of ports
    # (or output symbols) from a given list of states.
    # Also takes a current state of port dictionary for looking up data.
    #
    #   - portDict = dictionary of reachable ports from each state
    #   - stateList = list of states, from which reachable ports are searched
    def createPortSet(portDict: dict, stateList) -> set:
        allSetLists = []
        for i in stateList:
            allSetLists.append(portDict[i])
        # create cartesian product of setlists
        # => list of tuples of lists of sets
        tupleList = product(allSetLists, repeat=len(allSetLists))
        result = []
        for tuple in tupleList:  # iterate over each tuple of lists of sets
            for setList in tuple:  # iterate over each list of sets:
                unionSet = set()  # create a union of each set from the setlist
                for unitSet in setList:  # iterate over each set
                    unionSet |= unitSet
                if unionSet not in result:
                    result.append(unionSet)
        return result
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # initialization phase
    worklist = ta.getOutputStates()
    done = {}
    arityDict = ta.getSymbolArityDict()
    for symbol, stateList in ta.getOutputEdges().items():
        if not symbol.startswith("Port"):
            continue
        for state in stateList:
            if state not in done:
                done[state] = []
            if symbol not in done[state]:
                done[state].append(set([symbol]))

    # bottom-up parsing phase
    while len(worklist) > 0:
        state = worklist.pop()
        if state in ta.rootStates and state in done:
            if len(done[state]) != ta.portArity:
                return False
        for symbol, arity in arityDict.items():
            if arityDict[symbol] == 0:
                continue
            # all possible combinations of children with 'state' in there
            tuples = generatePossibleChildren(state, list(done), arity)
            for stateName, edgeDict in ta.transitions.items():
                for edge in edgeDict.values():
                    if (edge.info.label != symbol or edge.children not in tuples):
                        continue
                    if stateName not in done:
                        done[stateName] = []
                        worklist.append(stateName)
                    portSet = createPortSet(done, edge.children)
                    for i in portSet:
                        if i not in done[stateName]:
                            done[stateName].append(i)
    return True


def isWellDefined(ta: TTreeAut, errDisplay=False) -> bool:

    wellDefinedConditions = {
        "1-non-emptiness": True,
        "2-trimness": True,
        "3-port-consistency": True,
        "4-root-uniqueness": True,
        "5-non-vacuity": True,
        "6-port-uniqueness": True,
        "7-unambiguity": True,
    }

    # 1) Non-emptiness  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    witnessTree, witnessString = nonEmptyBU(ta)
    if witnessTree is None or witnessString == "":
        wellDefinedConditions["1-non-emptiness"] = False

    # 2) Trimness - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    allStates = ta.getStates()
    if (
        set(reachableBU(ta)) != set(allStates)
        or set(reachableTD(ta)) != set(allStates)
    ):
        wellDefinedConditions["2-trimness"] = False

    # 3) Port consistency - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if not portConsistencyCheck(ta):
        wellDefinedConditions["3-port-consistency"] = False

    # 4) Root-uniqueness  - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if len(ta.rootStates) != 1:
        wellDefinedConditions["4-root-uniqueness"] = False

    # 5) Non-vacuity  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    for i in ta.rootStates:
        rootEdges = ta.transitions[i]
        for edge in rootEdges.values():
            if len(edge.children) == 0 and edge.info.label.startswith("Port"):
                wellDefinedConditions["5-non-vacuity"] = False

    # 6) Port-uniqueness  - - - - - - - - - - - - - - - - - - - - - - - - - - -
    outputEdges = ta.getOutputEdges()
    portCounter = 0
    for symbol in outputEdges:
        if symbol.startswith("Port"):
            portCounter += 1
            if len(outputEdges[symbol]) != 1:
                wellDefinedConditions["6-port-uniqueness"] = False
    if portCounter != ta.getPortArity():
        wellDefinedConditions["6-port-uniqueness"] = False

    # 7) Unambiguity TODO - - - - - - - - - - - - - - - - - - - - - - - - - - -
    sth = False
    if sth:
        wellDefinedConditions["7-unambiguity"] = True

    # Final processing  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    boxIsWellDefined = True
    errorMsg = f"   > isWellDefined('{ta.name}'): failed conditions = "
    for condition, value in wellDefinedConditions.items():
        if value is False:
            errorMsg += f"{condition} "
            boxIsWellDefined = False
    if not boxIsWellDefined and errDisplay:
        print(errorMsg)
    return boxIsWellDefined


def areCommutative(ta1: TTreeAut, ta2: TTreeAut) -> bool:
    suffix = ta1.createSuffix()
    prefix = ta2.createPrefix(ta1.getOutputSymbols())
    intersection = treeAutIntersection(suffix, prefix)
    witnessT, _ = nonEmptyBU(intersection)
    return witnessT is None


def areComparable(ta1: TTreeAut, ta2: TTreeAut):
    infix = ta1.createInfix(ta2.getOutputEdges())
    language = {**ta1.getSymbolArityDict(), **ta2.getSymbolArityDict()}
    complement = treeAutComplement(infix, language)
    # print(complement)
    intersection = treeAutIntersection(complement, ta2)
    witnessT, _ = nonEmptyBU(intersection)
    return witnessT is None


# This is strictly for compacting the UBDA before output for testing purposes.
# Instead of many identical edges (with just different variables),
# the edges are merged into one where variables are compacted into one string.
# This provides much more readable format.
# Only use this function before outputting the UBDA.
def compressVariables(ta: TTreeAut) -> TTreeAut:
    temp = {}
    for edgeDict in ta.transitions.values():
        for edge in edgeDict.values():
            # boxNames parsing for the key:
            boxesStr = ""
            for box in edge.info.boxArray:
                if box is None:
                    boxName = "_"
                else:
                    boxName = box if type(box) == str else box.name
                    if boxName.startswith("box"):
                        boxName = boxName[len("box"):]
                boxesStr += "," + boxName
            boxesStr.lstrip(",")
            # end fo boxNames parsing
            tempKey = f"{edge.src}-{edge.info.label}{boxesStr}-{edge.children}"
            if tempKey not in temp:
                temp[tempKey] = [[], []]
            temp[tempKey][0] = [
                edge.src,
                edge.info.label,
                edge.info.boxArray,
                edge.children
            ]
            temp[tempKey][1].append(edge.info.variable)

    transitions = {}
    for key, edgeData in temp.items():
        src = edgeData[0][0]
        symb = edgeData[0][1]
        boxArray = edgeData[0][2]
        children = edgeData[0][3]
        vars = ",".join(edgeData[1])
        edge = TEdge(symb, boxArray, vars)
        if src not in transitions:
            transitions[src] = {}
        transitions[src][key] = TTransition(src, edge, children)
    result = TTreeAut(ta.rootStates, transitions, f"{ta.name}", ta.portArity)
    return result

# End of file ta_functions.py
