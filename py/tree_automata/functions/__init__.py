# All operations for tree automata (TA) implemented in this package:

# - complement(TA)
from tree_automata.functions.complement import tree_aut_complement

# - determinize(TA) creates a deterministic (and complete) TA from a NTA
from tree_automata.functions.determinization import tree_aut_determinization

# - non_emptiness_check(TA) checks whether a language of TA is non-empty
from tree_automata.functions.emptiness import non_empty_bottom_up, non_empty_top_down

# - intersection(TA1, TA2)
from tree_automata.functions.intersection import tree_aut_intersection

# - compare_two_boxes(TA1, TA2) - isomoprhism check
from tree_automata.functions.isomorphism import tree_aut_isomorphic

# TODO: maybe also make a version with variables and some additional heuristics

# - match(TA, tree) checks whether a tree can be generated by a tree automaton
from tree_automata.functions.match_tree import match_tree_bottom_up, match_tree_top_down

from tree_automata.functions.reachability import reachable_bottom_up, reachable_top_down

# - remove_useless_states(TA) removes unreachable states from a TA
from tree_automata.functions.trimming import remove_useless_states, shrink_to_top_down_reachable

# - union(TA1, TA2)
from tree_automata.functions.union import tree_aut_union

# - well_defined_check(TA) checks for conditions of a proper "box"
# box = a special tree automaton encoding repeating node patterns in BDDs
# that is used in ABDDs to reduce state space
from tree_automata.functions.well_defined import is_well_defined

# - generate_witness(TA) creates an example of a tree generated by the TA
from tree_automata.functions.witness import generate_witness_string, generate_witness_tree
