# taLib.py
# Basic functions for working with tree automata (from taLib.py)
# Implementation of tree automata for article about automata-based BDDs
# Author: Jany26  (Jan Matufka)  <xmatuf00@stud.fit.vutbr.cz>


from taClasses import *
from itertools import product

from typing import Tuple
import copy


# All operations for tree automata (TA) implemented in this module:
# - match(TA, tree) - checks whether a tree can be generated by a tree automaton
# - determinize(TA) - creates a deterministic (and complete) tree automaton from a NTA
# - union(TA1, TA2)
# - intersection(TA1, TA2)
# - complement(TA)
# - removeUselessStates(TA) - removes unreachable states from a TA
# - nonEmptinessCheck(TA) - checks whether a TA can generate non-empty set of trees
# - generateWitness(TA) - creates an example of a tree generated by the TA (if possible)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# SUBFUNCTIONS / HELPER FUNCTIONS
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Helper function for bottom-up tree parsing
# creates all possible variations (with repetition) of items from list of "parents" of a given length ("size"),
# such that the variation (stored in a list) contains the "state" item at least once
# note: assumes, that the "state" is in parents "list"
def generatePossibleChildren(state:str, parents:list, size:int) -> list:
    possibilites = product(parents, repeat = size)
    result = []
    for k in possibilites:
        if state in k:
            result.append(list(k))
    return result
    
# helper functions for determinization
# assume that stateList is already a set
def makeNameFromSet(stateList:list) -> str:
    stateList.sort()
    result = "{"
    for i in range(len(stateList)):
        result += str(stateList[i])
        result += ", "
    return result.rstrip(", ") + "}"


def makeSetFromName(name:str) -> list:
    temp = name.lstrip("{").rstrip("}").split(",")
    result = []
    for i in temp:
        result.append(i.strip())
    return result

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## helper function for generating tree starting from a specified node
# uses a dictionary of transitions (only 1 needed for each state)
def generateWitnessTree(transitions:dict, root:str) -> TTreeNode:
    if (type(transitions) is None or type(root) is None):
        return None
    if len(transitions[root][2]) == 0:
        return TTreeNode(transitions[root][1])
    else:
        tempNode = TTreeNode(transitions[root][1])
        for i in transitions[root][2]:
            tempChild = generateWitnessTree(transitions, i)
            tempNode.connectChild(tempChild)
        return tempNode


## helper function for generating a string that represents a tree, starts from root
# uses dictionary of transitions (only 1 needed for each state)
def generateWitnessString(transitions:dict, root:str) -> str:
    if len(transitions[root][2]) == 0:
        return str(transitions[root][1])
    else:
        parentString = str(transitions[root][1]) + "["
        for i in range(len(transitions[root][2])):
            childString = generateWitnessString(transitions, transitions[root][2][i])
            parentString += childString
            if i < len(transitions[root][2]) - 1:
                parentString += ";"
        return parentString + "]"


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# BASIC OPERATIONS ON TREE AUTOMATA
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


## Logical equivalent to function accept(DFA, string)
# works recursively, as all children from array have to be matched
def matchTreeTD(ta:TTreeAut, root:TTreeNode):

    def matchTopDown(ta:TTreeAut, node:TTreeNode, state:str):
        descendantTuples = []

        for stateName, edge in ta.transitions.items():
            for data in edge.values():
                if stateName == state and node.value == data[1]:
                    descendantTuples.append(data[2])
        
        for tuple in descendantTuples:
            b = True
            # when tree unexpected amount children than expected
            if len(tuple) != len(node.children):
                break
            for i in range(len(tuple)):
                # recursive matching for all children
                b = matchTopDown(ta, node.children[i], tuple[i])
                if not b:
                    break
            if b:
                return True
        
        return False

    ## ## ## ##

    for rootPtr in ta.rootStates:
        if matchTopDown(ta, root, rootPtr) == True:
            return True
    return False

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


## Logical equivalent to function accept(DFA, string)
# works recursively, but starts the matching process from the leaves
# instead of starting from the root
def matchTreeBU(ta:TTreeAut, root:TTreeNode):

    def matchBottomUp(ta:TTreeAut, root:TTreeNode) -> list:
        result = []
        if len(root.children) == 0:
            for stateName, edge in ta.transitions.items():
                for data in edge.values():
                    if (
                        data[1] == root.value # or symbol
                        and len(data[2]) == 0
                        and stateName not in result
                    ):
                        result.append(stateName)
            return result
        else:
            childrenSymbols = []
            for i in range(len(root.children)):
                childrenSymbols.append(matchBottomUp(ta, root.children[i]))
            for stateName, edge in ta.transitions.items():
                for data in edge.values():
                    if data[1] == root.value: # or symbol
                        x = True
                        for i in range(len(data[2])):
                            if data[2][i] not in childrenSymbols[i]:
                                x = False
                                break
                        if x:
                            result.append(stateName)
            return result
    ## ## ## ##

    result = matchBottomUp(ta, root)
    temp = []
    for value in result:
        if value in ta.rootStates:
            temp.append(value)
    return len(temp) != 0




# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


## TODO
#


# pseudo-code:

# def determinize(states, alphabet, rootstates, transitions):
#     # s is in powerset of states
#     workList = []
#     doneStates = []
#     doneTransitions = {}
    
#     while workList not empty: # until no rule can be added to doneTransitions
#         state = workList.pop()
#         doneStates.append(state)
#         temp = all possible transitions from state to children from doneStates
#         doneTransitions.append(temp)
# ...
# ...

# input: NFTA A = (Q, F, Qf, Delta)
# begin:
#     /* s is in powerset(Q) */
#     set Q_d to empty, set DELTA_Dd to empty
#     repeat
#         Q_d += {s}
#         DELTA_d += {f(s1, ..., sn) -> s}
#         where
#             f in Fn, 
#             s1,...sn in Q_d
#             s = {q in Q_d | exists q1 in s1, ...., qn in sn, f(q1, ..., qn) -> q in Delta}
#     until no rule can be added to DELTAd
#     set Qdf to all state sets, that contain at least state from Qf
# end
# output: DFTA Ad = (Qd, F, Qdf, DELTAd)

def treeAutDeterminization(ta:TTreeAut, alphabet:dict) -> TTreeAut:
    workSet = []
    doneStates = []
    doneTransitions = {}
    outEdges = ta.getOutputEdges()
    for symbol in outEdges:
        state = makeNameFromSet(outEdges[symbol])
        key = str(state) + '-' + str(symbol) + '-[]'

        doneTransitions[state] = {}
        doneTransitions[state][key] = [state, symbol, []]

        workSet.append(makeSetFromName(state))
        doneStates.append(makeSetFromName(state))

    # TTreeAut([], doneTransitions).printTreeAut()
    
    while len(workSet) > 0:
        stateSet = workSet.pop() 
        # in this case, workSet contains lists of states (or rather, "sets" of states)
        arityDict = ta.getSymbolArityDict()
        # alphabet is a list of tuples: ("symbol", arity)
        for symbol in arityDict:
            arity = arityDict[symbol]
            for state in stateSet: # iterate over each state from stateSet
                possibleTuples = []
                for doneState in doneStates:
                    possibleTuples = generatePossibleChildren(state, doneState, arity)
                    # if tuples != []:
                    #     print(str(symbol) + " " + str(state) + " " + str(doneState))
                    #     print(str(tuples) + "\n")
                    for edges in ta.transitions.values():
                        for data in edges.values():
                            if data[2] in possibleTuples:
                                new = True
                                # for 
                                # print("OK" + str(data[2]))

            
            

    return copy.deepcopy(ta)

# def nonEmptyBottomUp(ta:TTreeAut) -> bool:
#     workList = ta.getOutputStates()
#     done = ta.getOutputStates()
#     while len(workList) > 0:
#         state = workList.pop()
#         if state in ta.rootStates:
#             return True
#         arityDict = ta.getSymbolArityDict()
#         for symbol in arityDict:
#             arity = arityDict[symbol]
#             if not arity > 0:
#                 continue
#             allPossibleTuples = generatePossibleChildren(state, done, arity)
#             for stateName, content in ta.transitions.items():
#                 for transition in content.values():
#                     if (
#                         transition[1] != symbol
#                         or transition[2] not in allPossibleTuples
#                     ):
#                         continue
#                     if stateName not in done:
#                         workList.append(stateName)
#                         done.append(stateName)
#     return False

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


## Creates a tree automaton, that generates trees which can be generated by 
#  at least one of its two input automatons.
# 
#  just merging transition dictionaries and set of rootstates
#  before merging, name resolution is needed for states with the same name
def treeAutUnion(ta1:TTreeAut, ta2:TTreeAut) -> TTreeAut:
    result = copy.deepcopy(ta2)

    # remove name collisions by renaming states in a new automaton
    for stateName in ta1.transitions:
        if stateName in result.transitions:
            result.renameState(stateName, str(stateName) + "_new")
    
    # merge the two automata
    result.transitions = {**result.transitions, **ta1.transitions}
    result.rootStates = result.rootStates + ta1.rootStates
    return result


## Creates a tree automaton, that only generates trees which can be generated by
#  both its input automatons.
def treeAutIntersection(ta1:TTreeAut, ta2:TTreeAut) -> TTreeAut:
    result = TTreeAut([], {})
    for stateName1, content1 in ta1.transitions.items():
        for stateName2, content2 in ta2.transitions.items():
            newStateName = "(" + stateName1 + ", " + stateName2 + ")"
            if stateName1 in ta1.rootStates and stateName2 in ta2.rootStates:
                result.rootStates.append(newStateName)
            for key1, transition1 in content1.items():
                for key2, transition2 in content2.items():
                    newTransition = []
                    # merge transition keys 
                    newKey = "(" + key1 + ", " + key2 + ")"

                    # check if the arity is consistent (for now we just assume it is)
                    if len(transition1[2]) != len(transition2[2]):
                        continue
                    
                    # TODO: consider how to handle not-matching ports
                    # if (transition1[1] == transition2[1]) or (transition1[1].startswith("Port") and transition2[1].startswith("Port")):
                    
                    # adding new transition to the intersection if possible
                    if transition1[1] == transition2[1]:

                        # TODO: consider port adding (differentiating ports - maybe by some counter)
                        # newTransition.append("Port") if transition1[1].startswith("Port") else newTransition.append(transition1[1])
                        
                        # merge source state names -> 'q1' with 'q2' create '(q1, q2)'
                        newTransition.append("(" + transition1[0] + ", " + transition2[0] + ")")
                        newTransition.append(transition1[1])
                        childStates = []
                        for i in range(len(transition1[2])):
                            childStates.append("(" + transition1[2][i] + ", " + transition2[2][i] + ")")
                        newTransition.append(childStates)

                        # add state to transition dictionary 
                        if newStateName not in result.transitions:
                            result.transitions[newStateName] = {}
                        # add transition to transitions in a state dictionary
                        result.transitions[newStateName][newKey] = newTransition
    return result


## creates a tree automaton that can only generate trees, that cant be generated by the input TA
# uses determinization and completion of the TA beforehand
def treeAutComplement(ta:TTreeAut, alphabet) -> TTreeAut:
    result = treeAutDeterminization(ta, {})
    for stateName in result.transitions:
        if stateName in result.rootStates:
            result.rootStates.remove(stateName)
        else:
            result.rootStates.append(stateName)
    return result


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #



## Returns True if the tree automaton has non empty tree "language"
# meaning the tree automaton can generate at least one tree
# returns a trivial example of a tree generated by the tree automaton and its string representation
# if the language is empty, None and empty string is returned
def nonEmptyTD(ta:TTreeAut) -> Tuple[TTreeNode, str]:
    for root in ta.rootStates:
        edges = {}
        stack = []
        # trying to find an output for each root state (either directly or through children)
        if outputSearchTD(ta, root, stack, edges):
            return generateWitnessTree(edges, root), generateWitnessString(edges, root)
    return None, ""

## returns True if the state from a tree automaton can generate output (in finite amount of steps)
# uses top-down approach and thus backtracking, which requires a stack for remembering visited states
# as the tree is being parsed, edge lookup dictionary is being filled, 
#   - this dictionary is then used in witness generation (example of a tree generated by the TA)
def outputSearchTD(ta:TTreeAut, state:str, stack:list, edgeLookup:dict) -> bool:
    if (
        state in stack
        or state not in ta.transitions
        or len(ta.transitions[state]) == 0
    ):
        return False

    stack.append(state)

    # look for output edges first... at least one is needed to return
    for transition in ta.transitions[state].values():
        if len(transition[2]) == 0:
            stack.pop()
            edgeLookup[state] = transition
            return True

    # no direct  output edge detected, now trying to recursively find output edges
    # trying to generate outputs from all children in at least one transition
    for transition in ta.transitions[state].values():
        b = True
        for i in transition[2]:
            b = outputSearchTD(ta, i, stack, edgeLookup)
            if not b:
                break
        if b:
            stack.pop()
            edgeLookup[state] = transition
            return True
    stack.pop()
    return False

## Bottom-up version of non empty language check
# starts the mock tree generation from the leaves (states with output transitions)
# same signature as top-down version
def nonEmptyBU(ta:TTreeAut) -> Tuple[TTreeNode, str]:
    # initialization phase (finding all output )
    workList = ta.getOutputStates()
    done = {}
    for state in workList:
        for transition in ta.transitions[state].values():
            if len(transition[2]) == 0:
                done[state] = transition

    # tree automaton bottom-up parsing phase
    while len(workList) != 0:
        state = workList.pop()
        if state in ta.rootStates:
            # return generateTrivialTree(done, state)
            return generateWitnessTree(done, state), generateWitnessString(done, state)
        arityDict = ta.getSymbolArityDict()
        for symbol in arityDict:
            if arityDict[symbol] == 0:
                continue
            allPossibleTuples = generatePossibleChildren(state, list(done), arityDict[symbol])
            for stateName, content in ta.transitions.items():
                for transition in content.values():
                    if (
                        transition[1] != symbol
                        or transition[2] not in allPossibleTuples
                    ):
                        continue
                    if stateName not in done:
                        workList.append(stateName)
                        done[stateName] = transition
    return None, ""


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


## Searches the tree from bottom-up and from top-down, removing unreachable states
def removeUselessStates(ta:TTreeAut):
    reachableStatesBU = reachableBU(ta)
    ta.shrinkTA(reachableStatesBU)
    reachableStatesTD = reachableTD(ta)
    ta.shrinkTA(reachableStatesTD)
    return ta


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


## Generates a list of states reachable from the root states
def reachableTD(ta:TTreeAut) -> list:
    workList = copy.deepcopy(ta.rootStates)
    result = copy.deepcopy(ta.rootStates)

    while len(workList) > 0:
        state = workList.pop()
        content = ta.transitions[state]
        for transition in content.values():
            for i in transition[2]:
                if i not in result:
                    workList.append(i)
                    result.append(i)
    return result


## Generates a list of states reachable from the leaf states
def reachableBU(ta:TTreeAut) -> list:
    workList = ta.getOutputStates()
    result = ta.getOutputStates() # dict
    while len(workList) > 0:
        state = workList.pop()
        arityDict = ta.getSymbolArityDict()
        # check for root -> True
        for symbol in arityDict:
            arity = arityDict[symbol]
            if not arity > 0:
                continue
            allPossibileTuples = generatePossibleChildren(state, result, arity)
            for stateName, content in ta.transitions.items():
                for transition in content.values():
                    if (
                        transition[1] != symbol
                        or transition[2] not in allPossibileTuples
                    ):
                        continue
                    if stateName not in result:
                        workList.append(stateName)
                        result.append(stateName) # similarly for dictionary
    return result

# End of file taLib.py
