"""
[file] ta_functions.py
[author] Jany26  (Jan Matufka)  <xmatuf00@stud.fit.vutbr.cz>
[description] Basic functions for working with tree automata (from taLib.py)
"""

from ta_classes import *
from utils import *

from itertools import product
from typing import Tuple

import copy

# All operations for tree automata (TA) implemented in this module:
# - match(TA, tree) checks whether a tree can be generated by a tree automaton
# - determinize(TA) creates a deterministic (and complete) TA from a NTA
# - union(TA1, TA2)
# - intersection(TA1, TA2)
# - complement(TA)
# - remove_useless_states(TA) removes unreachable states from a TA
# - non_emptiness_check(TA) checks whether a language of TA is non-empty
# - generate_witness(TA) creates an example of a tree generated by the TA

# MAYBE TODO
# - compare_two_boxes(TA1, TA2) - isomoprhism check

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# SUBFUNCTIONS / HELPER FUNCTIONS
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Helper function for bottom-up tree parsing
# - (determinization, reachability, non_emptiness)


# Creates all possible variations (with repetition) of items
#  from list of "parents" of a given length ("size"),
#  such that the variation (stored in a list)
#  contains the "state" item at least once
#  note: assumes, that the "state" is in parents "list"
def generate_possible_children(state: str, parents: list, size: int) -> list:
    possibilities = product(parents, repeat=size)
    result = [list(k) for k in possibilities if state in k]
    # for k in possibilities:
    #     if state in k:
    #         result.append(list(k))
    return result


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Non emptiness check (+ witness generation) helper functions


# # Helper function for generating tree starting from a specified node
#   uses a dictionary of transitions (only 1 needed for each state)
def generate_witness_tree(edge_dict: dict, root: str) -> TTreeNode:
    if type(edge_dict) is None or type(root) is None:
        return None
    if len(edge_dict[root].children) == 0:
        return TTreeNode(f"({edge_dict[root].info.label};{root})")
    else:
        temp_node = TTreeNode(f"({edge_dict[root].info.label};{root})")
        for i in edge_dict[root].children:
            temp_child = generate_witness_tree(edge_dict, i)
            temp_node.connect_child(temp_child)
        return temp_node


# # Helper function for generating a string that represents a tree, top-down,
#   uses dictionary of transitions (only 1 needed for each state)
def generate_witness_string(edge_dict: dict, root: str) -> str:
    if len(edge_dict[root].children) == 0:
        return str(edge_dict[root].info.label)
    else:
        parent_string = str(edge_dict[root].info.label) + "["
        for i in range(len(edge_dict[root].children)):
            child_string = generate_witness_string(edge_dict, edge_dict[root].children[i])
            parent_string += child_string
            if i < len(edge_dict[root].children) - 1:
                parent_string += ";"
        return parent_string + "]"


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# BASIC OPERATIONS ON TREE AUTOMATA
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# # Logical equivalent to function accept(DFA, string)
#   works recursively, as all children from array have to be matched
def match_tree_top_down(ta: TTreeAut, root: TTreeNode) -> bool:

    # Helper function for match_tree_top_down  - - - - - - - - - - - - - - - - -

    def match_top_down(ta: TTreeAut, node: TTreeNode, state: str) -> bool:
        child_tuples = []

        for state_name, edge in ta.transitions.items():
            for data in edge.values():
                if state_name == state and node.value == data.info.label:
                    child_tuples.append(data.children)

        for tuple in child_tuples:
            b = True
            # when tree unexpected amount children than expected
            if len(tuple) != len(node.children):
                break
            for i in range(len(tuple)):
                # recursive matching for all children
                b = match_top_down(ta, node.children[i], tuple[i])
                if not b:
                    break
            if b:
                return True
        return False

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    for r in ta.roots:
        if match_top_down(ta, root, r) is True:
            return True
    return False


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Logical equivalent to function accept(DFA, string)
#  works recursively, but starts the matching process from the leaves
#  instead of starting from the root
def match_tree_bottom_up(ta: TTreeAut, root: TTreeNode) -> bool:
    # Helper function for match_tree_bottomup - - - - - - - - - - - - - - - - -
    def match_bottom_up(ta: TTreeAut, root: TTreeNode) -> list:
        result = []
        if len(root.children) == 0:
            for state_name, edge in ta.transitions.items():
                for data in edge.values():
                    if (
                        data.info.label == root.value  # or symbol
                        and len(data.children) == 0
                        and state_name not in result
                    ):
                        result.append(state_name)
            return result

        else:
            child_symbols = []
            for i in range(len(root.children)):
                child_symbols.append(match_bottom_up(ta, root.children[i]))
            for state_name, edge in ta.transitions.items():
                for data in edge.values():
                    if data.info.label == root.value:  # or symbol
                        x = True
                        for i in range(len(data.children)):
                            if data.children[i] not in child_symbols[i]:
                                x = False
                                break
                        if x:
                            result.append(state_name)
            return result

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    result = match_bottom_up(ta, root)
    temp = []
    for value in result:
        if value in ta.roots:
            temp.append(value)
    return len(temp) != 0


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Helper functions for BU-determinization - - - - - - - - - - - - - - - - -


# creates a string (state name) from list of states -- e.g. '{a,b,c}'
def det_create_name(state_list: list) -> str:
    my_list = state_name_sort(state_list)
    return "{" + ",".join(my_list) + "}"


# Create a "reverse" transition dictionary, in which parents of specified edges
#  can be found -- important for bottom-up algorithms (determinization).
#  Lookup goes like this:
#    symbol -> children -> then the parent/source state is found
#  Note: list of children is "stringified"
# {symbol : {"children" : [parents]}}
def det_create_lookup(ta: TTreeAut, alphabet) -> dict:
    result = {symbol: {} for symbol in alphabet}
    for edges in ta.transitions.values():
        for edge in edges.values():
            symbol = edge.info.label

            if str(edge.children) not in result[symbol]:
                result[symbol][str(edge.children)] = []

            if edge.src not in result[symbol][str(edge.children)]:
                result[symbol][str(edge.children)].append(edge.src)
    return result


# Creates all needed permutations for determinization consideration,
#  which contain the specified 'state' and other states are filled with states
#  from the 'states' (to get the specific permutation 'size').
def det_generate_tuples(states: list, state: list, size: int) -> list:
    prod = product(states, repeat=size)
    return [list(i) for i in prod if state in i]


# Creates a list of output states based on the symbols.
def det_out_edges(out_edges: list, done_edges, alphabet):
    result = []
    for symbol in out_edges:
        done_edges.append([out_edges[symbol], symbol, []])
        result.append(out_edges[symbol])

    for symbol in alphabet:
        if symbol not in out_edges and alphabet[symbol] == 0:
            done_edges.append([[], symbol, []])
            if [] not in result:
                result.append([])
    return result


# Finds all possible source states (parents) for a set of given
#  macrostates (lists of states) - parameter 'tuple'.
#  For this, a lookup dictionary is created at the start of determinization.
#  Function tries to perform a bottom-up step:
#  trying to find a feasible transition from a given children tuple
def det_child_handle(tuple: list, lookup: dict) -> list:
    children = [list(i) for i in product(*tuple)]
    result = []
    for i in children:
        if str(i) not in lookup:
            continue
        for j in lookup[str(i)]:
            if j in result:
                continue
            result.append(j)
    result.sort()
    return result


# This function creates a transition dict for the resulting tree automaton,
#  based on the ad-hoc data notes created during determinization.
#  The result is in the right format needed for TTreeAut class.
def det_create_relation(edge_list: list, alphabet: dict) -> dict:
    edge_dict = {}
    # print(f"> ALPHABET\n{alphabet}")
    for edge in edge_list:
        # print(f"  > EDGE = {edge}")
        source = det_create_name(edge[0])
        symbol = TEdge(edge[1], [None] * alphabet[str(edge[1])], "")
        # print(f"    > SRC = {source}")
        # print(f"    > SYM = {edge[1]}")
        # print(f"    > CHI = {edge[2]}")
        children = [det_create_name(i) for i in edge[2]]
        key = f"{source}-{edge[1]}->({children})"
        if source not in edge_dict:
            edge_dict[source] = {}
        edge_dict[source][key] = TTransition(source, symbol, children)
    return edge_dict


def det_create_roots(done_states: list, roots: list) -> list:
    result = set()
    for done_set in done_states:
        for root in roots:
            if root in done_set:
                result.add(det_create_name(done_set))
    return list(result)


# Creates a deterministic and complete version of the "ta"
#  tree automaton with regards to the "alphabet"
#  alphabet is a dictionary -> key = "symbol", value = arity (integer)
#  done_states = list of macrostates (macrostate = list of states/strings)
#  done_transitions = dictionary of transitions,
#  key is just some string created from done_states by a function
#       - each key references a list/dict of all possible transitions
#  the transitions themselves look like this:
#       [ parent_macro_state, symbol, child_macro_state_list ]
#       - parent_macro_state = list of states
#       - symbol =
#       - child_macro_state_list = list of lists of states
#           - from which the states in parent_macro_state can be reached
#             through an edge labeled with the symbol
#
#  * IMPORTANT NOTE
#     = done_states and done_transitions are just placeholder structures
#       - in the final automaton the macro_states
#         (list/set of states) will be represented by a string
#       - this string is created using make_name_from_set() function
def tree_aut_determinization(ta: TTreeAut, alphabet: dict, verbose=False) -> TTreeAut:

    parent_lookup = det_create_lookup(ta, alphabet)
    done_tuples = {symbol: {} for symbol in alphabet}
    done_edges = []
    done_set = det_out_edges(ta.get_output_edges(), done_edges, alphabet)
    work_set = copy.deepcopy(done_set)
    if verbose:
        print("{:<60} {:<20} {:<60} {:<5} {:<5}".format("current_state", "symbol", "children", "work", "done"))
        print("-" * 160)
        counter = 0
    while work_set != []:
        state = work_set[0]
        work_set.remove(state)
        done_set.append(state)
        for symbol, arity in alphabet.items():
            lookup = parent_lookup[symbol]
            if lookup == {}:
                # TODO: HANDLE UNUSED SYMBOL
                pass
            combinations = det_generate_tuples(done_set, state, arity)
            for tuple in combinations:
                # print(combinations)
                if str(tuple) in done_tuples[symbol]:
                    continue
                if verbose:
                    counter += 1
                    print(
                        "{:<60} {:<20} {:<60} {:<5} {:<5}".format(
                            f"{counter}) {state}"[:60], symbol[:20], str(tuple)[:60], len(work_set), len(done_set)
                        )
                    )
                parents = det_child_handle(tuple, lookup)
                done_tuples[symbol][str(tuple)] = parents
                if parents not in work_set:
                    work_set.append(parents)
                done_edges.append([parents, symbol, tuple])

    new_roots = det_create_roots(done_set, ta.roots)
    new_edges = det_create_relation(done_edges, alphabet)
    result = TTreeAut(new_roots, new_edges, f"determinized({ta.name})")
    result.port_arity = result.get_port_arity()

    if verbose:
        print(f"determinization of {ta.name} done")

    return result


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Creates a tree automaton, that generates trees which can be generated by
#  at least one of its two input automatons.
#
#  just merging transition dictionaries and set of rootstates
#  before merging, name resolution is needed for states with the same name
def tree_aut_union(ta1: TTreeAut, ta2: TTreeAut) -> TTreeAut:
    result = copy.deepcopy(ta2)
    result.name = f"union({ta1.name},{ta2.name})"

    # remove name collisions by renaming states in a new automaton
    for state_name in ta1.transitions:
        if state_name in result.transitions:
            result.rename_state(state_name, str(state_name) + "_new")

    # merge the two automata
    result.transitions = {**result.transitions, **ta1.transitions}
    result.roots = result.roots + ta1.roots
    result.port_arity = result.get_port_arity()
    return result


# Creates a tree automaton, that only generates trees which can be generated by
#  both its input automatons.
def tree_aut_intersection(ta1: TTreeAut, ta2: TTreeAut, verbose=False) -> TTreeAut:
    # Helper function, creates a pair key, [edgeInfo] for TAinteresction()
    #  based on the two keys and two edges from input.
    #  If possible, adds a new transition into the result dictionary
    counter = 0

    def handle_intersection_edge(k1: str, e1: list, k2: str, e2: list, result: TTreeAut, state: str):
        new_key = f"({k1},{k2})"  # merge transition keys
        new_state = f"({e1.src},{e2.src})"  # merge source state names
        # e.g. states 'q1' and 'q2' create '(q1, q2)'
        new_edge = copy.deepcopy(e1.info)  # new edge with same info
        # merged children
        new_children = [f"({e1.children[i]},{e2.children[i]})" for i in range(len(e1.children))]
        if verbose:
            print("{:<60} {:<40} {:<40}".format(f"{counter}) {state}"[:60], f"{k1}"[:40], f"{k2}"[:40]))

        if state not in result.transitions:
            result.transitions[state] = {}
        for child in new_children:
            if child not in result.transitions:
                result.transitions[child] = {}
        # add transition to transitions in a state dictionary
        # if verbose: print(new_key)
        result.transitions[state][new_key] = TTransition(new_state, new_edge, new_children)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # NOTE: consider how to handle not-matching ports
    # label1 = transition1.info.label
    # label2 = transition2.info.label
    # if ((label1.startswith("Port")
    #     and label2.startswith("Port")
    #     and label1 != label2)):
    #     do_whatever()
    #     pass

    # NOTE: consider port adding (differentiating ports maybe by a counter)
    # if transition1.info.startswith("Port"):
    #     new_transition.append("Port")
    # else:
    #     new_transition.append(transition1.info)

    if ta2 is None:
        return ta1
    if ta1 is None:
        return ta2

    result = TTreeAut([], {}, f"int({ta1.name},{ta2.name})")
    for s1, edges1 in ta1.transitions.items():
        for s2, edges2 in ta2.transitions.items():
            new_state = f"({s1},{s2})"
            if s1 in ta1.roots and s2 in ta2.roots:
                result.roots.append(new_state)
            for k1, e1 in edges1.items():  # key1, edge1
                for k2, e2 in edges2.items():  # key2, edge2
                    if len(e1.children) != len(e2.children):  # arity consistency
                        continue
                    if e1.info.label != e2.info.label:  # symbol consistency
                        continue
                    counter += 1
                    handle_intersection_edge(k1, e1, k2, e2, result, new_state)

    result.port_arity = result.get_port_arity()
    result.name = f"intersection({ta1.name},{ta2.name})"
    return result


# creates a tree automaton that can only generate trees,
#  that can not be generated by the input TA
#  - uses determinization and completion of the TA beforehand
def tree_aut_complement(ta: TTreeAut, alphabet: dict, verbose=False) -> TTreeAut:
    result = tree_aut_determinization(ta, alphabet, verbose)
    roots = [i for i in result.get_states() if i not in result.roots]
    result.roots = roots
    result.name = f"complement({ta.name})"
    return result


# needed for co-occurrence relation
def tree_aut_product(ta1: TTreeAut, ta2: TTreeAut) -> TTreeAut:

    def make_name_from_list(state_list: list) -> str:
        result = "("
        for i in range(len(state_list)):
            result += state_list[i]
            if i < len(state_list) - 1:
                result += ","
        result += ")"
        return result

    def create_roots(ta1: TTreeAut, ta2: TTreeAut) -> list:
        root_merge = []
        root_merge.append(ta1.roots)
        root_merge.append(ta2.roots)
        roots = product(*root_merge)
        return [list(i) for i in roots]

    def productify(state1, state2, ta1, ta2, edge_dict, done):
        if [state1, state2] in done:
            return
        done.append([state1, state2])
        for edge1 in ta1.transitions[state1].values():
            for edge2 in ta2.transitions[state2].values():
                src_state = [edge1.src, edge2.src]
                sym1 = edge1.info.label
                sym2 = edge2.info.label
                if len(edge1.children) == 0 and len(edge2.children) == 0:
                    # handle output symbols
                    if sym1 == sym2 or sym1.startswith("Port"):
                        edge_dict.append([src_state, sym1, []])

                if sym1 == sym2 and len(edge1.children) > 0:
                    children = []
                    for i in range(len(edge1.children)):
                        children.append([edge1.children[i], edge2.children[i]])
                    edge_dict.append([src_state, sym1, children])
                    for i in children:
                        if [i.src, i.info] not in done:
                            productify(i.src, i.info, ta1, ta2, edge_dict, done)

    def create_product_relation(edge_list: list, alphabet: dict) -> dict:
        edge_dict = {}
        for edge in edge_list:
            src_state = make_name_from_list(edge[0])
            if src_state not in edge_dict:
                edge_dict[src_state] = {}
            edge_obj = TEdge(edge[1], [None] * alphabet[edge[1]], "")
            children = [make_name_from_list(edge[2][i]) for i in range(len(edge[2]))]
            key = f"{src_state}-{edge[1]}-{children}"
            edge_dict[src_state][key] = [src_state, edge_obj, children]
        return edge_dict

    alphabet = {**ta1.get_symbol_arity_dict(), **ta2.get_symbol_arity_dict()}
    roots = create_roots(ta1, ta2)
    edge_list = []
    done = []
    for root in roots:
        productify(root[0], root[1], ta1, ta2, edge_list, done)

    new_roots = [make_name_from_list(i) for i in roots]
    edge_dict = create_product_relation(edge_list, alphabet)
    result = TTreeAut(new_roots, edge_dict, f"product({ta1.name},{ta2.name})", 0)
    result.port_arity = result.get_port_arity()

    return result


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Returns a "witness tree" if the tree automaton has non empty tree "language"
#  Witness tree is just an example of most trivial
#  trees generated by this automaton.
#  If the TA has empty language, a tuple (None, "") is returned
#  meaning the tree automaton can generate at least one tree
#  returns a trivial example of a tree
#  that can be generated by the tree automaton
#  and its string representation
#  if the language is empty, None and empty string is returned
def non_empty_top_down(ta: TTreeAut, verbose=False) -> Tuple[TTreeNode, str]:

    def non_empty_top_down_init_func(ta: TTreeAut) -> Tuple[dict, dict]:
        edge_lookup = {}
        out_dict = {}
        for out_symbol, state_list in ta.get_output_edges().items():
            for state in state_list:
                if state in edge_lookup:
                    continue
                out_dict[state] = True
                edge_lookup[state] = TTransition(state, TEdge(out_symbol, [], ""), [])

        return edge_lookup, out_dict

    def debug_output(out_dict, edge_lookup):
        true_list = []
        false_list = []
        for state, value in out_dict.items():
            true_list.append(state) if value else false_list.append(state)
        print(f"  TRUE -> {true_list}")
        print(f"  FALSE -> {false_list}")
        for state, edge in edge_lookup.items():
            print(f"  {state} -> {edge}")

    # Returns True if the state from a tree automaton
    #  can generate output (in finite amount of steps)
    #  uses top-down approach and thus backtracking,
    #  which requires a stack for remembering visited states
    #  as the tree is being parsed, edge lookup dictionary is being filled,
    #    - this dictionary is then used in witness generation
    #  * note: witness = example of a tree generated by the TA
    def output_search_top_down(
        ta: TTreeAut, state: str, visited: list, out_dict: dict, edge_lookup: dict, debug, total
    ) -> bool:
        if (
            state in visited  # breaking endless recursion
            or state not in ta.transitions  # skipping if state has no entry
            or len(ta.transitions[state]) == 0  # or an empty entry
        ):
            # if debug: print("    > FALSE ... self-loop or invalid state")
            if debug:
                print("{:<40} {:<5} {:<30}".format(f"{state}"[:40], f"SKIP", f""))
            return False

        if debug:
            print("{:<60} {:<120} {:<12}".format(f"state " + "-" * 54, f"callstack " + "-" * 108, f"done", f"function"))
            print(
                "{:<60} {:<120} {:<12}".format(
                    f"{state}"[:60], f"{visited}"[:120], f"{len(out_dict)}/{total}", f"neTD({ta.name})"
                )
            )

        for edge in ta.transitions[state].values():
            # skipping self-looping transitions
            if state in edge.children:
                continue
            output_reachable = True
            for child in edge.children:
                # checking if the state has been already visited
                # and we know if its OK
                if child in out_dict:
                    if out_dict[child]:
                        if debug:
                            print("{:<40} {:<5} {:<50}".format(f"{state}"[:40], f"TRUE", f"direct | {state}"))
                        continue
                    else:
                        if debug:
                            print("{:<40} {:<5} {:<50}".format(f"{state}"[:40], f"FALSE", f"direct | {state}"))
                        output_reachable = False
                        break
                # we dont know anything about the state =
                visited.append(state)
                # print(f"checking {child} -> ??? GOING DEEPER")
                output_reachable = output_search_top_down(ta, child, visited, out_dict, edge_lookup, debug, total)
                visited.remove(state)
                # skipping NOT OK transition
                if not output_reachable:
                    break

            # found an OK transition
            if output_reachable:
                if debug:
                    ln = len(visited)
                    print(
                        "{:<40} {:<5} {:<30}".format(
                            f"{state}"[:40], f"TRUE", f"recursion | {visited[ln-1]}" if ln > 0 else "root"[:30]
                        )
                    )
                out_dict[state] = True
                edge_lookup[state] = edge
                # call_stack.remove(state)
                return True

        if debug:
            ln = len(visited)
            print(
                "{:<40} {:<5} {:<30}".format(
                    f"{state}"[:40], f"FALSE", f"recursion | {visited[ln-1]}" if ln > 0 else "root"[:30]
                )
            )
        out_dict[state] = False

        # callStack.remove(state)
        return False

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    total = len(ta.get_states())  # for debug
    edge_lookup, out_dict = non_empty_top_down_init_func(ta)
    for root in ta.roots:
        if output_search_top_down(ta, root, [], out_dict, edge_lookup, verbose, total):
            if verbose:
                print(f"{ta.name} has non-empty lang")
            witness_tree = generate_witness_tree(edge_lookup, root)
            witness_string = generate_witness_string(edge_lookup, root)
            return witness_tree, witness_string
    if verbose:
        print(f"{ta.name} has empty lang")
    return None, ""


# Bottom-up version of non empty language check
#  starts the mock tree generation from the leaves
#  same signature as top-down version
#  * leaves = states with output transitions
def non_empty_bottom_up(ta: TTreeAut, verbose=False) -> Tuple[TTreeNode, str]:
    if verbose:
        print(
            "{:<60} {:<20} {:<20} {:<20} {:<20} {:<20}".format(
                "state", "symbol", "workset", "doneset", "allstates", "function"
            )
        )
        print("-" * 150)
        counter = 0

    # initialization phase (finding all output )
    worklist = ta.get_output_states()
    size = len(ta.get_states())
    done = {}
    done_set = ta.get_output_states()
    arity_dict = ta.get_symbol_arity_dict()
    for state in worklist:
        for edge in ta.transitions[state].values():
            if len(edge.children) == 0:
                done[state] = edge

    def print_done_edges(done_edges: dict):
        result = []
        for i in done_edges.values():
            result.append([i[0], i[1].label, i[2]])
        for j in result:
            print(j)
        print()

    # tree automaton bottom-up parsing phase
    while len(worklist) != 0:
        state = worklist[0]
        worklist.remove(worklist[0])
        if state not in done_set:
            done_set.append(state)
        if state in ta.roots:
            if verbose:
                print(f">> {ta.name} has non-empty lang")
            witness_tree = generate_witness_tree(done, state)
            witness_string = generate_witness_string(done, state)
            return witness_tree, witness_string
        for symbol in arity_dict:
            arity = arity_dict[symbol]
            if arity == 0:
                continue
            # tuples = all possible combinations of children lists with 'state'
            tuples = generate_possible_children(state, list(done), arity)
            if verbose:
                counter += 1
                print(
                    "{:<60} {:<20} {:<20} {:<20} {:<20} {:<20}".format(
                        f"{counter}) {state}",
                        f"{symbol}",
                        f"{len(worklist)}",
                        f"{len(done_set)}",
                        f"{size}",
                        f"neBU({ta.name})",
                    )
                )
            # for state_name, edge_dict in ta.transitions.items():
            #     for edge in edge_dict.values():
            for edge in iterate_edges(ta):
                if edge.info.label != symbol or edge.children not in tuples:
                    continue
                if edge.src not in done:
                    worklist.append(edge.src)
                    done[edge.src] = edge

    if verbose:
        print(f">> {ta.name} has empty lang")
    return None, ""


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Searches the tree from bottom-up and from top-down,
#  removing unreachable states
def remove_useless_states(ta: TTreeAut) -> TTreeAut:
    work_ta = copy.deepcopy(ta)
    bottom_up_reachable_states = reachable_bottom_up(work_ta)
    work_ta.shrink_tree_aut(bottom_up_reachable_states)
    top_down_reachable_states = reachable_top_down(work_ta)
    work_ta.shrink_tree_aut(top_down_reachable_states)
    return work_ta


def shrink_to_top_down_reachable(ta: TTreeAut) -> TTreeAut:
    work_ta = copy.deepcopy(ta)
    top_down_reachable_states = set(reachable_top_down(work_ta))
    unreachable_states = set(i for i in work_ta.get_states() if i not in top_down_reachable_states)
    for i in unreachable_states:
        work_ta.transitions.pop(i)
    return work_ta


def get_all_state_reachability(ta: TTreeAut, reflexive=False) -> dict:
    old_roots = [i for i in ta.roots]
    result = {}
    for i in ta.get_states():
        ta.roots = [i]
        result[i] = set(reachable_top_down(ta, count_itself=reflexive))
    ta.roots = [i for i in old_roots]
    return result


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Generates a list of states reachable from the root states
def reachable_top_down(ta: TTreeAut, count_itself=True) -> list:
    worklist = [i for i in ta.roots]
    result = [i for i in ta.roots] if count_itself is True else []

    while len(worklist) > 0:
        state = worklist.pop()

        if state not in ta.transitions:
            continue

        for edge in ta.transitions[state].values():
            for i in edge.children:
                if i not in result:
                    worklist.append(i)
                    result.append(i)
    return result


# Generates a list of states reachable from the leaf states
def reachable_bottom_up(ta: TTreeAut) -> list:

    # this is needed for some longer children arrays
    # {'symbol1' : {'state1': 2, 'state2': 1}, 'symbol2': ...}
    def create_state_arity_dict(ta) -> dict:
        result = {}
        arities = ta.get_symbol_arity_dict()
        for symbol, arity in arities.items():
            if arity == 0:
                continue
            if symbol not in result:
                result[symbol] = {}
            for state in ta.get_states():
                if state not in result[symbol]:
                    result[symbol][state] = []

        for edge in iterate_edges(ta):
            child_set = set(edge.children)
            symbol = edge.info.label
            if arities[symbol] == 0:
                continue
            length = len(edge.children)
            for state in child_set:
                if length not in result[symbol][state]:
                    result[symbol][state].append(length)
        return result

    worklist = ta.get_output_states()
    result = ta.get_output_states()
    arity_dict = ta.get_symbol_arity_dict()
    extended_arity_dict = create_state_arity_dict(ta)
    while len(worklist) > 0:
        state = worklist.pop()
        for symbol, arity in arity_dict.items():
            if arity <= 0:
                continue

            arities = extended_arity_dict[symbol][state]
            tuples = []
            for a in arities:
                tuples.extend(generate_possible_children(state, result, a))

            # for state_name, edge_dict in ta.transitions.items():
            #     for edge in edge_dict.values():
            for edge in iterate_edges(ta):
                if edge.info.label != symbol or edge.children not in tuples:
                    continue
                if edge.src not in result:
                    worklist.append(edge.src)
                    result.append(edge.src)  # similarly for dictionary
    return result


# One of the rule-checks for a well-defined tree automaton (box).
#  Implements bottom-up search and keeps information about all reachable port
#  combinations from a given state.
#
#  Each root state has to be able to reach a precise amount of ports, which is
#  given by TAs port-arity.
def port_consistency_check(ta: TTreeAut) -> bool:

    # Helper function, creates a list of sets,
    # which correspond to all possible reachable combinations of ports
    # (or output symbols) from a given list of states.
    # Also takes a current state of port dictionary for looking up data.
    #
    #   - port_dict = dictionary of reachable ports from each state
    #   - state_list = list of states, from which reachable ports are searched
    def create_port_set(port_dict: dict, state_list) -> set:
        all_set_lists = []
        for i in state_list:
            all_set_lists.append(port_dict[i])
        # create cartesian product of setlists
        # => list of tuples of lists of sets
        tuple_list = product(all_set_lists, repeat=len(all_set_lists))
        result = []
        for tuple in tuple_list:  # iterate over each tuple of lists of sets
            for set_list in tuple:  # iterate over each list of sets:
                union_set = set()  # create a union of each set from the setlist
                for unit_set in set_list:  # iterate over each set
                    union_set |= unit_set
                if union_set not in result:
                    result.append(union_set)
        return result

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # initialization phase
    worklist = ta.get_output_states()
    done = {}
    arity_dict = ta.get_symbol_arity_dict()
    for symbol, state_list in ta.get_output_edges().items():
        if not symbol.startswith("Port"):
            continue
        for state in state_list:
            if state not in done:
                done[state] = []
            if symbol not in done[state]:
                done[state].append(set([symbol]))

    # bottom-up parsing phase
    while len(worklist) > 0:
        state = worklist.pop()
        if state in ta.roots and state in done:
            if len(done[state]) != ta.port_arity:
                return False
        for symbol, arity in arity_dict.items():
            if arity_dict[symbol] == 0:
                continue
            # all possible combinations of children with 'state' in there
            tuples = generate_possible_children(state, list(done), arity)

            # for edge.src, edgeDict in ta.transitions.items():
            #     for edge in edgeDict.values():
            for edge in iterate_edges(ta):
                if edge.info.label != symbol or edge.children not in tuples:
                    continue
                if edge.src not in done:
                    done[edge.src] = []
                    worklist.append(edge.src)
                port_set = create_port_set(done, edge.children)
                for i in port_set:
                    if i not in done[edge.src]:
                        done[edge.src].append(i)
    return True


def is_well_defined(ta: TTreeAut, display_errors=False) -> bool:

    conditions = {
        "1-non-emptiness": True,
        "2-trimness": True,
        "3-port-consistency": True,
        "4-root-uniqueness": True,
        "5-non-vacuity": True,
        "6-port-uniqueness": True,
        "7-unambiguity": True,
    }

    # 1) Non-emptiness  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    witness_tree, witness_str = non_empty_bottom_up(ta)
    if witness_tree is None or witness_str == "":
        conditions["1-non-emptiness"] = False

    # 2) Trimness - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    all_states = ta.get_states()
    if set(reachable_bottom_up(ta)) != set(all_states) or set(reachable_top_down(ta)) != set(all_states):
        conditions["2-trimness"] = False

    # 3) Port consistency - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if not port_consistency_check(ta):
        conditions["3-port-consistency"] = False

    # 4) Root-uniqueness  - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if len(ta.roots) != 1:
        conditions["4-root-uniqueness"] = False

    # 5) Non-vacuity  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    for i in ta.roots:
        edges_from_root = ta.transitions[i]
        for edge in edges_from_root.values():
            if len(edge.children) == 0 and edge.info.label.startswith("Port"):
                conditions["5-non-vacuity"] = False

    # 6) Port-uniqueness  - - - - - - - - - - - - - - - - - - - - - - - - - - -
    output_edges = ta.get_output_edges()
    port_counter = 0
    for symbol in output_edges:
        if symbol.startswith("Port"):
            port_counter += 1
            if len(output_edges[symbol]) != 1:
                conditions["6-port-uniqueness"] = False
    if port_counter != ta.get_port_arity():
        conditions["6-port-uniqueness"] = False

    # 7) Unambiguity TODO - - - - - - - - - - - - - - - - - - - - - - - - - - -
    sth = False
    if sth:
        conditions["7-unambiguity"] = True

    # Final processing  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    result = True
    error_msg = f"   > is_well_defined('{ta.name}'): failed conditions = "
    for condition, value in conditions.items():
        if value is False:
            error_msg += f"{condition} "
            result = False
    if not result and display_errors:
        print(error_msg)
    return result


# these functions (commutativity and comparability checks) were supposed to
# help with finding the optimal "total" box ordering with regards to their
# reduction capabilities, however, this attempt lead nowhere,
# so it is left unused
def are_commutative(ta1: TTreeAut, ta2: TTreeAut) -> bool:
    suffix = ta1.create_suffix()
    prefix = ta2.create_prefix(ta1.get_output_symbols())
    intersection = tree_aut_intersection(suffix, prefix)
    witness_t, _ = non_empty_bottom_up(intersection)
    return witness_t is None


def are_comparable(ta1: TTreeAut, ta2: TTreeAut):
    infix = ta1.create_infix(ta2.get_output_edges())
    language = {**ta1.get_symbol_arity_dict(), **ta2.get_symbol_arity_dict()}
    complement = tree_aut_complement(infix, language)
    # print(complement)
    intersection = tree_aut_intersection(complement, ta2)
    witnessT, _ = non_empty_bottom_up(intersection)
    return witnessT is None


# This is strictly for compacting the UBDA before output for testing purposes.
# Instead of many identical edges (with just different variables),
# the edges are merged into one where variables are compacted into one string.
# This provides much more readable format.
# Only use this function before outputting the UBDA.
def compress_vars(ta: TTreeAut) -> TTreeAut:
    temp = {}
    for edge in iterate_edges(ta):
        # box_names parsing for the key:
        boxes_str = ""
        for box in edge.info.box_array:
            if box is None:
                box_name = "_"
            else:
                box_name = box if type(box) == str else box.name
                if box_name.startswith("box"):
                    box_name = box_name[len("box") :]
            boxes_str += "," + box_name
        boxes_str.lstrip(",")
        # end of box_names parsing
        temp_key = f"{edge.src}-{edge.info.label}{boxes_str}-{edge.children}"
        if temp_key not in temp:
            temp[temp_key] = [[], []]
        temp[temp_key][0] = [edge.src, edge.info.label, edge.info.box_array, edge.children]
        temp[temp_key][1].append(edge.info.variable)

    transitions = {}
    for key, edge_data in temp.items():
        src = edge_data[0][0]
        symb = edge_data[0][1]
        box_array = edge_data[0][2]
        children = edge_data[0][3]
        vars = ",".join(edge_data[1])
        edge = TEdge(symb, box_array, vars)
        if src not in transitions:
            transitions[src] = {}
        transitions[src][key] = TTransition(src, edge, children)
    result = TTreeAut(ta.roots, transitions, f"{ta.name}", ta.port_arity)
    return result


# End of file ta_functions.py
