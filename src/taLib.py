# taLib.py
# Basic functions for working with tree automata (from taLib.py)
# Implementation of tree automata for article about automata-based BDDs
# Author: Jany26  (Jan Matufka)  <xmatuf00@stud.fit.vutbr.cz>

# import sys
# import os
import copy
import re
from taClasses import *
from itertools import permutations, product

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# BASIC OPERATIONS ON TREE AUTOMATA
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def matchTree(ta:TTreeAut, root:TTreeNode):
    for rootPtr in ta.rootStates:
        if match(ta, root, rootPtr) == True:
            return True
    return False

def match(ta:TTreeAut, node:TTreeNode, state:str):
    descendantTuples = []

    # maybe needs polishing
    for stateName, content in ta.transitions.items():
        for key, transition in content.items():
            if stateName == state and node.value == transition[1]:
                descendantTuples.append(transition[2])
    
    for tuple in descendantTuples:
        b = True
        # when tree unexpected amount children than expected
        if len(tuple) != len(node.children):
            break
        for i in range(len(tuple)):
            # recursive matching for all children
            b = match(ta, node.children[i], tuple[i])
            if not b:
                break
        if b:
            return True
    
    return False

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Creates a tree automaton, that generates trees which can be generated by 
#  at least one of its two input automatons.
# 
#  just merging transition dictionaries and set of rootstates
#  before merging, name resolution is needed for states with the same name
def treeAutUnion(ta1:TTreeAut, ta2:TTreeAut) -> TTreeAut:
    result = copy.deepcopy(ta2)

    # remove name collisions by renaming states in a new automaton
    for stateName in ta1.transitions:
        if stateName in result.transitions:
            result.renameState(stateName, str(stateName) + "_new")
    
    # merge the two automata
    result.transitions = {**result.transitions, **ta1.transitions}
    result.rootStates = result.rootStates + ta1.rootStates
    return result

## Creates a tree automaton, that only generates trees which can be generated by
#  both its input automatons.
def treeAutIntersection(ta1:TTreeAut, ta2:TTreeAut) -> TTreeAut:
    result = TTreeAut([], {})
    for stateName1, content1 in ta1.transitions.items():
        for stateName2, content2 in ta2.transitions.items():
            newStateName = "(" + stateName1 + ", " + stateName2 + ")"
            if stateName1 in ta1.rootStates and stateName2 in ta2.rootStates:
                result.rootStates.append(newStateName)
            for key1, transition1 in content1.items():
                for key2, transition2 in content2.items():
                    # adding new transition to the intersection if possible
                    newTransition = []
                    newKey = "(" + key1 + ", " + key2 + ")"
                    if len(transition1[2]) != len(transition2[2]):
                        # TODO error handle
                        continue
                    # if (transition1[1] == transition2[1]) or (transition1[1].startswith("Port") and transition2[1].startswith("Port")):
                    if transition1[1] == transition2[1]:
                        # check if the arity is consistent (for now we just assume it is)
                        newTransition.append("(" + transition1[0] + ", " + transition2[0] + ")")
                        # newTransition.append("Port") if transition1[1].startswith("Port") else newTransition.append(transition1[1])
                        newTransition.append(transition1[1])
                        childStates = []
                        for i in range(len(transition1[2])):
                            childStates.append("(" + transition1[2][i] + ", " + transition2[2][i] + ")")
                        newTransition.append(childStates)

                        # add state to transition dictionary 
                        if newStateName not in result.transitions:
                            result.transitions[newStateName] = {}
                        # add transition to transitions in a state dictionary
                        result.transitions[newStateName][newKey] = newTransition
    return result

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def treeAutDeterminize(ta:TTreeAut) -> TTreeAut:
    return copy.deepcopy(ta)

def treeAutComplement(ta:TTreeAut) -> TTreeAut:
    result = treeAutDeterminize(ta)
    rootStates = []
    for stateName, content in result.transitions.items():
        if stateName in result.rootStates:
            rootStates.pop(stateName)
        else:
            rootStates.append(stateName)
    return TTreeAut(rootStates, result.transitions)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## needs to break recursion with some sort of a list or sth
def outputCheckTD(state:str, ta:TTreeAut, stack) -> bool:
    if (
        state in stack
        or state not in ta.transitions
        or len(ta.transitions[state]) == 0
    ):
        return False

    stack.append(state)

    # look for output edges first... at least one is needed for True
    for key, transition in ta.transitions[state].items():
        if len(transition[2]) == 0:
            stack.pop()
            return True

    # no output edge detected, now trying to recursively find output edges
    # trying to generate outputs from all children in at least one transition
    for key, transition in ta.transitions[state].items():
        b = True
        for i in transition[2]:
            b = outputCheckTD(i, ta, stack)
            if not b:
                break
        if b:
            stack.pop()
            return True
    stack.pop()
    return False

def nonEmptyTopDown(ta:TTreeAut) -> bool:
    for root in ta.rootStates:
        stack = []
        if outputCheckTD(root, ta, stack) == True:
            return True
    return False

def nonEmptyBottomUp(ta:TTreeAut) -> bool:
    pass

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

def topDownReachable(ta:TTreeAut) -> list:
    # PSEUDO-CODE
    #
    # worklist = treeAut.rootStates
    # done = treeAut.rootStates
    # while len(worklist) > 0:
    #     q = worklist.pop()
    #     for q --[a]--> (r[1], ..., r[n]):
    #         for i in range(n):
    #             if r[i] not in done:
    #                 worklist.append(r[i])
    #                 done.append(r[i])
    # return done

    workList = copy.deepcopy(ta.rootStates)
    result = copy.deepcopy(ta.rootStates)

    while len(workList) > 0:
        state = workList.pop()
        content = ta.transitions[state]
        for key, transition in content.items():
            for i in transition[2]:
                if i not in result:
                    workList.append(i)
                    result.append(i)
    return result


def generatePossibleChildren(state:str, parents:list, size:int) -> list:
    result = []
    possibilites = product(parents, repeat = size)
    for k in possibilites:
        if state in k:
            result.append(list(k))
    return result
    

def bottomUpReachable(ta:TTreeAut) -> list:
    # PSEUDO-CODE
    # 
    # worklist = { q | q -> ()}
    # result = worklist
    # while len(worklist) > 0:
    #     q = worklist.pop()
    #     for a in alphabet and arity(a) > 0:
    #         generate all tuples t from result, that contain q
    #             --- ("variations" of tuples, can contain q more than once)
    #         for s --[a]-->  t:
    #             if s not in result:
    #                 worklist.append(s)
    #                 result.append(s)
    # return result
    
    workList = ta.getOutputStates()
    result = ta.getOutputStates()
    while len(workList) > 0:
        state = workList.pop()
        arityDict = ta.getSymbolArityDict()
        for symbol in arityDict:
            arity = arityDict[symbol]
            if not arity > 0:
                continue
            allPossibileTuples = generatePossibleChildren(state, result, arity)
            for stateName, content in ta.transitions.items():
                for key, transition in content.items():
                    if (
                        transition[0] != stateName
                        or transition[1] != symbol
                        or transition[2] not in allPossibileTuples 
                    ):
                        continue
                    if stateName not in result:
                        workList.append(stateName)
                        result.append(stateName)
        
    return result

## Shrinks tree automaton to only contain the states from list
def shrinkTA(ta:TTreeAut, states:list):
    toDelete = []
    for stateName in ta.transitions:
        if stateName not in states:
            toDelete.append(stateName)
    for i in toDelete:
        ta.removeState(i)

def removeUselessStates(ta:TTreeAut):
    reachableStatesBU = bottomUpReachable(ta)
    shrinkTA(ta, reachableStatesBU)
    reachableStatesTD = topDownReachable(ta)
    shrinkTA(ta, reachableStatesTD)
    return ta

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# FUNCTIONS FOR TESTING PURPOSES
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Does not cover edge cases! (e.g. wrong string structure)
def getNodeFromString(string:str):
    string = string.strip()
    nodeName = re.match("^[\w]+", string).group()
    string = string.lstrip(str(nodeName))
    node = TTreeNode(nodeName)
    return node, string

## Recursive function to generate a tree from a structured string
# XYZ [...] = node with list of children following (can be nested)
# [ node1 ; node2 [...] ; node3 ; ... ] = list of children of a previous node
def buildTreeFromString(currentNode:TTreeNode, string:str):
    string = string.strip() # skipping whitespaces

    # empty string - ending recursion
    if len(string) == 0:
        return currentNode
    
    # starting children generation (down a level)
    if string.startswith("["):
        node, string = getNodeFromString(string[1:]) 
        currentNode.connectChild(node)
        return buildTreeFromString(node, string)

    # continuing children generation (same level)
    elif string.startswith(";"):
        node, string = getNodeFromString(string[1:])
        currentNode.parent.connectChild(node)
        return buildTreeFromString(node, string)

    # ending children generation - returning to a parent (up a level)
    elif string.startswith("]"):
        return buildTreeFromString(currentNode.parent, string[1:])

    # start of a string - root creation (initial case - no special character at the beginning)
    else:
        root, string = getNodeFromString(string)
        return buildTreeFromString(root, string)

# End of file taLib.py
