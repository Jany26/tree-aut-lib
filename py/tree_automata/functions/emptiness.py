from typing import Optional

from tree_automata import TTreeAut, TTransition, TEdge, TTreeNode, iterate_edges
from tree_automata.functions.helpers import generate_possible_children
from tree_automata.functions.witness import generate_witness_string, generate_witness_tree


def non_empty_top_down_init_func(ta: TTreeAut) -> tuple[dict[str, TTransition], dict[str, bool]]:
    edge_lookup: dict[str, TTransition] = {}
    out_dict: dict[str, bool] = {}
    for out_symbol, state_list in ta.get_output_edges().items():
        for state in state_list:
            if state in edge_lookup:
                continue
            out_dict[state] = True
            edge_lookup[state] = TTransition(state, TEdge(out_symbol, [], ""), [])

    return edge_lookup, out_dict


def debug_output(out_dict: dict[str, bool], edge_lookup: dict[str, TTransition]) -> None:
    """
    Print out debugging information for non_empty_top_down().
    """
    true_list: list[str] = []
    false_list: list[str] = []
    for state, value in out_dict.items():
        true_list.append(state) if value else false_list.append(state)
    print(f"  TRUE -> {true_list}")
    print(f"  FALSE -> {false_list}")
    for state, edge in edge_lookup.items():
        print(f"  {state} -> {edge}")


def output_search_top_down(
    ta: TTreeAut,
    state: str,
    visited: list[str],
    out_dict: dict[str, bool],
    edge_lookup: dict[str, TTransition],
    debug: bool,
    total: int,
) -> bool:
    """
    Return True if the state from a tree automaton can generate output (in finite amount of steps)
    uses top-down approach and thus backtracking, which requires a stack for remembering visited states
    as the tree is being parsed, edge lookup dictionary is being filled,
    - this dictionary is then used in witness generation

    note: witness = example of a tree generated by the TA
    """
    if (
        state in visited  # breaking endless recursion
        or state not in ta.transitions  # skipping if state has no entry
        or len(ta.transitions[state]) == 0  # or an empty entry
    ):
        # if debug: print("    > FALSE ... self-loop or invalid state")
        if debug:
            print("{:<40} {:<5} {:<30}".format(f"{state}"[:40], f"SKIP", f""))
        return False

    if debug:
        print("{:<60} {:<120} {:<12}".format(f"state " + "-" * 54, f"callstack " + "-" * 108, f"done", f"function"))
        print(
            "{:<60} {:<120} {:<12}".format(
                f"{state}"[:60], f"{visited}"[:120], f"{len(out_dict)}/{total}", f"neTD({ta.name})"
            )
        )

    for edge in ta.transitions[state].values():
        # skipping self-looping transitions
        if state in edge.children:
            continue
        output_reachable: bool = True
        for child in edge.children:
            # checking if the state has been already visited
            # and we know if its OK
            if child in out_dict:
                if out_dict[child]:
                    if debug:
                        print("{:<40} {:<5} {:<50}".format(f"{state}"[:40], f"TRUE", f"direct | {state}"))
                    continue
                else:
                    if debug:
                        print("{:<40} {:<5} {:<50}".format(f"{state}"[:40], f"FALSE", f"direct | {state}"))
                    output_reachable = False
                    break
            # we dont know anything about the state =
            visited.append(state)
            # print(f"checking {child} -> ??? GOING DEEPER")
            output_reachable: bool = output_search_top_down(ta, child, visited, out_dict, edge_lookup, debug, total)
            visited.remove(state)
            # skipping NOT OK transition
            if not output_reachable:
                break

        # found an OK transition
        if output_reachable:
            if debug:
                ln: int = len(visited)
                print(
                    "{:<40} {:<5} {:<30}".format(
                        f"{state}"[:40], f"TRUE", f"recursion | {visited[ln-1]}" if ln > 0 else "root"[:30]
                    )
                )
            out_dict[state] = True
            edge_lookup[state] = edge
            # call_stack.remove(state)
            return True

    if debug:
        ln: int = len(visited)
        print(
            "{:<40} {:<5} {:<30}".format(
                f"{state}"[:40], f"FALSE", f"recursion | {visited[ln-1]}" if ln > 0 else "root"[:30]
            )
        )
    out_dict[state] = False

    # callStack.remove(state)
    return False


def non_empty_top_down(ta: TTreeAut, verbose=False) -> tuple[Optional[TTreeNode], str]:
    """
    Returns a "witness tree" if the tree automaton has non empty tree "language".
    Witness tree is just an example of most trivial trees generated by this automaton.
    If the TA has empty language, a tuple (None, "") is returned.

    The witness tree generation starts from the root nodes and uses backtracking.
    (i.e. if some branch of the tree cannot be finished -- cannot end with an output transition,
    the computation returns upwards and recursively tries other branches).

    Note: For a witness tree, it should suffice to use some transition max. once.
    """
    total: int = len(ta.get_states())  # for debug
    edge_lookup, out_dict = non_empty_top_down_init_func(ta)
    for root in ta.roots:
        if output_search_top_down(ta, root, [], out_dict, edge_lookup, verbose, total):
            if verbose:
                print(f"{ta.name} has non-empty lang")
            witness_tree: TTreeNode = generate_witness_tree(edge_lookup, root)
            witness_string: str = generate_witness_string(edge_lookup, root)
            return witness_tree, witness_string
    if verbose:
        print(f"{ta.name} has empty lang")
    return None, ""


def print_done_edges(done_edges: dict[str, TTransition]) -> None:
    for i in done_edges.values():
        print([i.src, i.info.label, i.children])
    print()


def non_empty_bottom_up(ta: TTreeAut, verbose=False) -> tuple[Optional[TTreeNode], str]:
    """
    Bottom-up version of non empty language check
    starts the mock tree generation from the leaves
    same signature as top-down version
    * leaves = states with output transitions
    """
    if verbose:
        print(
            "{:<60} {:<20} {:<20} {:<20} {:<20} {:<20}".format(
                "state", "symbol", "workset", "doneset", "allstates", "function"
            )
        )
        print("-" * 150)
        counter = 0

    # initialization phase (finding all output starting points)
    worklist: list[str] = ta.get_output_states()
    size: int = len(ta.get_states())
    done: dict[str, TTransition] = {}
    done_set: list[str] = ta.get_output_states()
    arity_dict: dict[str, int] = ta.get_symbol_arity_dict()
    for state in worklist:
        for edge in ta.transitions[state].values():
            if len(edge.children) == 0:
                done[state] = edge

    # tree automaton bottom-up parsing phase
    while len(worklist) != 0:
        state: str = worklist.pop(0)
        if state not in done_set:
            done_set.append(state)
        if state in ta.roots:
            if verbose:
                print(f">> {ta.name} has non-empty lang")
            witness_tree: TTreeNode = generate_witness_tree(done, state)
            witness_string: str = generate_witness_string(done, state)
            return witness_tree, witness_string
        for symbol in arity_dict:
            arity: int = arity_dict[symbol]
            if arity == 0:
                continue
            # tuples = all possible combinations of children lists with 'state'
            tuples: list[list[str]] = generate_possible_children(state, list(done), arity)
            if verbose:
                counter += 1
                print(
                    "{:<60} {:<20} {:<20} {:<20} {:<20} {:<20}".format(
                        f"{counter}) {state}",
                        f"{symbol}",
                        f"{len(worklist)}",
                        f"{len(done_set)}",
                        f"{size}",
                        f"neBU({ta.name})",
                    )
                )
            # for state_name, edge_dict in ta.transitions.items():
            #     for edge in edge_dict.values():
            for edge in iterate_edges(ta):
                if edge.info.label != symbol or edge.children not in tuples:
                    continue
                if edge.src not in done:
                    worklist.append(edge.src)
                    done[edge.src] = edge

    if verbose:
        print(f">> {ta.name} has empty lang")
    return None, ""
