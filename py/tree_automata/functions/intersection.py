"""
[file] emptiness.py
[author] Jany26  (Jan Matufka)  <xmatuf00@stud.fit.vutbr.cz>
[description] Intersection of two tree automata.
"""

import copy

from tree_automata import TTreeAut, TTransition, TEdge
from tree_automata.automaton import iterate_key_edge_tuples


def handle_intersection_edge(
    k1: str, e1: TTransition, k2: str, e2: TTransition, result: TTreeAut, counter: int, verbose: bool
) -> None:
    """
    Helper function, creates a pair key, [edgeInfo] for TAinteresction()
    based on the two keys and two edges from input.
    If possible, adds a new transition into the result dictionary
    """
    new_key: str = f"({k1},{k2})"  # merge transition keys
    new_state: str = f"({e1.src},{e2.src})"  # merge source state names
    # e.g. states 'q1' and 'q2' create '(q1, q2)'
    new_edge: TEdge = copy.deepcopy(e1.info)  # new edge with same info
    # merged children
    new_children: list[str] = [f"({e1.children[i]},{e2.children[i]})" for i in range(len(e1.children))]

    if verbose:
        print("{:<60} {:<40} {:<40}".format(f"{counter}) {new_state}"[:60], f"{k1}"[:40], f"{k2}"[:40]))

    if new_state not in result.transitions:
        result.transitions[new_state] = {}
    for child in new_children:
        if child not in result.transitions:
            result.transitions[child] = {}
    # add transition to transitions in a state dictionary
    if verbose:
        print(new_key)
    result.transitions[new_state][new_key] = TTransition(new_state, new_edge, new_children)


def tree_aut_intersection(ta1: TTreeAut, ta2: TTreeAut, verbose=False) -> TTreeAut:
    """
    Creates a tree automaton, that only generates trees which can be generated by
    both its input automatons (intersection of the given tree automata).
    """
    # NOTE: consider how to handle not-matching ports
    # label1 = transition1.info.label
    # label2 = transition2.info.label
    # if ((label1.startswith("Port")
    #     and label2.startswith("Port")
    #     and label1 != label2)):
    #     do_whatever()
    #     pass

    # NOTE: consider port adding (differentiating ports maybe by a counter)
    # if transition1.info.startswith("Port"):
    #     new_transition.append("Port")
    # else:
    #     new_transition.append(transition1.info)

    if ta2 is None:
        return ta1
    if ta1 is None:
        return ta2

    counter: int = 0
    result = TTreeAut([], {}, f"intersection({ta1.name},{ta2.name})")
    for k1, e1 in iterate_key_edge_tuples(ta1):
        for k2, e2 in iterate_key_edge_tuples(ta2):
            if e1.src in ta1.roots and e2.src in ta2.roots:
                result.roots.append(f"({e1.src},{e2.src})")
            if len(e1.children) != len(e2.children):  # arity consistency
                continue
            if e1.info.label != e2.info.label:  # symbol consistency
                continue
            counter += 1
            handle_intersection_edge(k1, e1, k2, e2, result, counter, verbose)

    result.port_arity = result.get_port_arity()
    result.name = f"intersection({ta1.name},{ta2.name})"
    return result


# End of file intersection.py
