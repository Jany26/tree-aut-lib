# ta_classes.py
# Basic classes needed for implementing tree automata
# Implementation of tree automata for article about automata-based BDDs
# Author: Jany26  (Jan Matufka)  <xmatuf00@stud.fit.vutbr.cz>

import copy
from utils import stateNameSort

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CLASSES FOR TREE AND TREE AUTOMATON
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


# Tree class (n-ary)
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Tree node implementation - items generated by tree automata
# tree is made of nodes,
# root node can be recognized with parent node set to 'None'
# other nodes have a parent,
# when connected using addChild() and connectChild() methods
#   * attribute 'value' = what is in the node
#   * attribute
class TTreeNode:
    def __init__(self, value):
        self.value = value
        self.parent = None  # if None = the node is a root
        self.children = []
        self.depth = 0

    # Recursively prints the whole node in somehow structured manner.
    # If called on root node, prints the whole tree
    def printNode(self, offset: int = 0):
        space = " " * offset
        temp = space + 2 * self.depth * ' ' + str(self.value)
        print(temp + "   --> lv " + str(self.depth))
        for i in self.children:
            i.printNode(offset)

    def updateDepth(self, newRootDepth: int):
        self.depth = newRootDepth
        for i in self.children:
            i.updateDepth(newRootDepth + 1)

    # Creates a child node with a specific value.
    # Connects the created node to the current node/parent.
    def addChild(self, value):
        childPtr = TTreeNode(value)
        childPtr.parent = self
        childPtr.updateDepth(self.depth + 1)
        self.children.append(childPtr)

    # Connects a specific node to current node
    def connectChild(self, node):
        self.children.append(node)
        node.parent = self
        node.updateDepth(self.depth + 1)

    # removes the "leftest" 1 child with specified value.
    def removeChild(self, value):
        for i in range(len(self.children)):
            if self.children[i].value == value:
                self.children.pop(i)
                return

    def getDepth(self) -> int:
        result = self.depth + 1
        for i in self.children:
            temp = i.getDepth()
            if temp > result:
                result = temp
        return result

    # Maybe redundant functions #

    def findFromLeft(self, valueToFind):
        for i in self.children:
            x = i.findFromLeft(valueToFind)
            if x is not None:
                return x
        return self if (self.value == valueToFind) else None

    def findFromRight(self, valueToFind):
        tempList = self.children[::-1]
        for i in tempList:
            x = i.findFromRight(valueToFind)
            if x is not None:
                return x
        return self if (self.value == valueToFind) else None


# Edge class (describing the "hyper-edge")
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Useful in UBDAs (unreduced binary decision automatons), where it is
# important to store more info about edges
#   * attribute 'variable'
#       - from which variable the edge starts (with the reduction)
#   * attribute 'boxArray'
#       - which boxes are used over each part of the "hyper-edge"
#       - contains references to boxes which are
#           used as a means of reduction over this part of the edge
#       - short edges (no box reduction) are just 'None'
#   * attribute 'label'
#       - describes the edge used (usually LH = low-high)
#       - could also be '0' / '1' / 'Port...', which have arity 0
#           * output transitions, states with these can be considered 'leaves'
#
#   * note: length of the boxArray = arity of the edge
class TEdge:
    def __init__(self, label: str, boxArray: list, variable: str):
        self.label: str = label
        self.boxArray: list[str] = boxArray
        self.variable: str = variable

    def __repr__(self):
        result = f"{self.label}"
        if self.variable != "":
            result += f" <{self.variable}>"
        boxArrayEmpty = True
        for i in self.boxArray:
            if i is not None:
                boxArrayEmpty = False

        if not boxArrayEmpty:
            result += " ["
            for i in self.boxArray:
                result += "_, " if i is None else (
                    f"{i}, " if type(i) == str else f"{i.name}, "
                )
            result = result[:-2]
            result += "]"
        return result

    # makes the hyper-edge 'short' (all parts of the edge)
    def shortenEdge(self):
        arity = len(self.boxArray)
        self.boxArray = [None] * arity

class TTransition:
    def __init__(self, src: str, info: TEdge, children: list[str]):
        self.src: str = src
        self.info: TEdge = info  # edge info (symbol, boxes, variable)
        self.children: list[str] = children

    def __repr__(self):
        # comment = " <<< LEAF TRANSITION >>>" if self.children == [] else ""
        return f"{self.src} -- {self.info} --> {self.children}"

    def checkSelfLoop(self):
        if self.src in self.children:
            return True
        return False
    
    def isSelfLoop(self):
        if self.src in self.children:
            return True
        return False

    def checkFullSelfLoop(self):
        for i in self.children:
            if i != self.src:
                return False
        return True
    
    def isFullSelfLoop(self):
        for i in self.children:
            if i != self.src:
                return False
        return True


# class TState:
#     def __init__(self, stateName: str, transDict: dict):
#         self.stateName = stateName
#         self.transitions = transDict

#     def __repr__(self):
#         return self.stateName


# Tree automaton class
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# - has two attributes = dictionary of states and root state array
#     transitions = dict (A) of dicts (B) referenced by state name
#     inner dicts (B) are then referenced by transition names (arbitrary)
#     the transition itself is then just a tuple of:
#         - input state,
#         - edge object (edge label, edge boxes, edge variable label)
#         - array of output states (size of array = arity of the node)
#     * all state and label names are considered as strings
#
#     In documentation, the naming convention will be:
#     - TTreeAut consists of: array of root states and "state" dictionary
#     - state dictionaries are referenced by names of the states
#     - each state in the state dictionary references another dictionary
#         - this will be called "transition" dictionary (for the current state)
#         - the transition dictionary is referenced by arbitrary keys (for now)
class TTreeAut:
    def __init__(
        self,
        rootStates: list[str],
        transitions: dict[str, dict[str, TTransition]],
        name: str,
        portArity: int = 0
    ):
        self.rootStates: list[str] = rootStates
        self.transitions: dict[str, dict[str, TTransition]] = transitions
        self.name: str = name
        self.portArity: int = portArity
        if self.portArity == 0:
            self.portArity = self.getPortArity()
        # this parameter is only for formatted printing with edge-keys
        self.printKeys: bool = True
        self.metaData: TTreeAutMetaData = TTreeAutMetaData(self)

    def __repr__(self):
        # printing tree automaton header
        result = ""
        # result = "-" * 78 + '\n'
        result += f"  [TreeAut]: '{self.name}'\n"
        result += f"  > Root States = {self.rootStates}\n"

        srcString = "source"
        edgeString = "edge"
        childString = "child #"
        keyString = "key"

        # computing lengths
        self.metaData.recompute()
        srcLen = max(len(srcString), self.metaData.state)
        edgeLen = max(len(edgeString), self.metaData.edge)
        childLen = max(len(childString), self.metaData.child)
        keyLen = max(len(keyString), self.metaData.key)

        # printing edge table header
        result += "  > %-*s -- %-*s --> " % (srcLen, srcString, edgeLen, edgeString)
        for i in range(self.metaData.arity):
            result += "%-*s  " % (childLen, f"{childString[:-2]} {i + 1}")
        if self.printKeys:
            result += "  %-*s" % (keyLen, keyString) + "\n"
            result += "  " + "-" * sum(
                [srcLen, edgeLen, keyLen, childLen * self.metaData.arity, 17]
            ) + '\n'
        else:
            result = result[:-2] + '\n'
            result += "  " + "-" * sum(
                [srcLen, edgeLen, childLen * self.metaData.arity, 13]
            ) + '\n'

        # printing edges
        for state in iterateBFS(self):
            for k, e in self.transitions[state].items():
                # note = " <<< LEAF TRANSITION >>>" if e.children == [] else ""
                # result += f"  > {e.src} -- {e.info} --> {e.children}{note}\n"
                result += "  > %-*s -- %-*s" % (
                    srcLen, e.src, edgeLen, e.info
                )
                if len(e.children) != 0:
                    result += " --> "
                    for i in e.children:
                        result += "%-*s  " % (childLen, i)
                    result = result[:-2]
                else:
                    result += " " * (self.metaData.arity * childLen + 7)
                if self.printKeys:
                    result += "  : %-*s" % (keyLen, k)
                result += "\n"
        # result = "-" * 78 + '\n'
        return result[:-1]  # trim the last '\n'

    # Check if two TAs are equivalent... NOTE: wip
    def __eq__(self, ta):
        # unique counter value will be used to compare states
        # states will be stored in two separate hash-maps, values will be counters
        # need to compare child counts, 
        # different, 'redundant' edges are stored in two separate places (maybe no)
        if len(self.rootStates) != len(ta.rootStates):
            return False
        stateMapper: dict[str, tuple(str, str)] = {}
        pass

    def getEdgeString(self, edge: TTransition) -> str:
        result = ""
        result += "%-*s -- %-*s" % (
            self.metaData.state, edge.src, self.metaData.edge, edge.info
        )
        if len(edge.children) != 0:
            result += " --> "
            for i in edge.children:
                result += "%-*s  " % (self.metaData.child, i)
        if self.printKeys is True:
            for k, e in self.transitions[edge.src].items():
                if str(edge) == str(e):
                    result += "  : %-*s" % (self.metaData.key, k)
        return result

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Informative functions # - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    def getStates(self) -> list:
        result = []
        for stateName in self.rootStates:
            result.append(stateName)
        for stateName, edges in self.transitions.items():
            result.append(stateName)
            for data in edges.values():
                for i in data.children:
                    result.append(i)
        result = list(set(result))
        result.sort()
        return result

    # needed for feeding makePrefix() function
    # generates all edge symbols labeling the output edges from the TA
    def getOutputSymbols(self) -> list:
        outputEdgeList = []
        for edgeDict in self.transitions.values():
            for edge in edgeDict.values():
                if len(edge.children) == 0:
                    outputEdgeList.append(edge.info.label)
        return outputEdgeList

    # needed for feeding treeAutDeterminize() function
    # generates a dictionary of all output edge symbols
    # which correspond to a list of states,
    # from which the transitions with the specific symbol originate
    def getOutputEdges(self, inverse=False) -> dict:
        result = {}
        for edge in transitions(self):
            if len(edge.children) == 0:
                if inverse:
                    if edge.src not in result:
                        result[edge.src] = []
                    result[edge.src].append(edge.info.label)
                else:
                    if edge.info.label not in result:
                        result[edge.info.label] = []
                    result[edge.info.label].append(edge.src)
        for item in result.values():
            item.sort()
        return result

    # needed for bottom-up reachability -> used in useless state removal
    def getOutputStates(self) -> list:
        outputStateList = []
        for stateName, edges in self.transitions.items():
            for data in edges.values():
                if len(data.children) == 0:
                    outputStateList.append(stateName)
                    break
        return outputStateList

    def getSymbolArityDict(self) -> dict:
        symbolDict = {}
        for edges in self.transitions.values():
            for edge in edges.values():
                if edge.info.label not in symbolDict:
                    if edge.info.boxArray == []:
                        symbolDict[edge.info.label] = len(edge.children)
                    else:
                        symbolDict[edge.info.label] = len(edge.info.boxArray)
        return symbolDict

    def getPortArity(self) -> int:
        portSet = set()
        for edgeDict in self.transitions.values():
            for edge in edgeDict.values():
                sym = edge.info.label
                if sym.startswith("Port"):
                    portSet.add(sym)
        return len(portSet)

    def isTDdeterministic(self) -> bool:
        for edgeDict in self.transitions.values():
            usedSymbols = set()
            for edge in edgeDict.values():
                if edge.info.label not in usedSymbols:
                    usedSymbols.add(edge.info.label)
                else:
                    return False
        return True

    def getVariableOrder(self) -> list:
        vars = set()
        for edgeDict in self.transitions.values():
            for edge in edgeDict.values():
                if edge.info.variable != "":
                    vars.add(edge.info.variable)
        vars = list(vars)
        vars = stateNameSort(vars)
        return vars

    def getVariablePrefix(self) -> str:
        """Returns largest prefix of a variable in a TA, 
        that does not contain only numeric symbols.

        Examples:
            'x1' - returns 'x'
            'var5ta01 - returns 'var5ta'
        """
        for edge in transitions(self):
            if edge.info.variable != "":
                prefixLen = 0
                for i in range(len(edge.info.variable)):
                    if not edge.info.variable[i:].isnumeric():
                        prefixLen += 1
                return edge.info.variable[:prefixLen]

    def countEdges(self):
        counter = 0
        for _ in transitions(self):
            counter += 1
        return counter

    # Returns a dictionary of states, each of which has a set of variables,
    # that the state can "see" = i.e. the state has a transition with
    # this variable. e.g. {'q0': {'x1', 'x2'}, 'q1': {'x5'}}
    # if reverse==True: the dictionary is referenced by variables, and values
    # are lists of states. e.g. {'x1': {'q0'}, 'x2': {'q0'}, 'x5': {'q1'}}
    def getVariablesVisibility(self, reverse=False) -> dict:
        result: dict[str, set] = {}
        for edge in transitions(self):
            if edge.info.variable != "":
                lookup = edge.info.variable if reverse else edge.src
                value = edge.src if reverse else edge.info.variable
                if lookup not in result:
                    result[lookup] = set()
                result[lookup].add(value)
        return result

    # Returns a list of all states that can be reached through 1 transition
    # from a specific state (only one directional)
    def reachableFrom(self, state: str) -> list:
        if state not in self.transitions:
            return []
        result = set()

        for edge in self.transitions[state].values():
            for child in edge.children:
                if child not in result:
                    result.add(child)
        return list(result)

    # Calculates the smallest "hop" distance to the specified state from root
    # Works similarly to BFS but uses helping list to stop an iteration after
    # initial stack is exhausted and increases the distance counter
    def getRootDistance(self, state: str) -> int:
        distance = 0
        visited = set()  # cuts looping (BFS)
        workList = [i for i in self.rootStates]  # work list =>
        stateCount = len(self.getStates())

        while len(visited) != stateCount:
            nextIteration = []
            while workList != []:
                currentState = workList.pop(0)
                if currentState == state:
                    return distance
                visited.add(currentState)
                for i in self.reachableFrom(currentState):
                    if i not in visited:
                        nextIteration.append(i)
            workList = [i for i in nextIteration]
            distance += 1

        raise Exception(f"getRootDistance(): {state} not found in {self.name}")

    # Calculates all possible paths through the TA.
    # Path must begin with a root state and end with a leaf
    # note: based on DFS
    # result is a list of paths, path is a lists of states
    def calculatePaths(self) -> list:
        def preOrderDFS(state, path, result):
            path.append(state)
            if state in leaves:
                result.append(copy.copy(path))
            for i in self.reachableFrom(state):
                if i not in path:
                    preOrderDFS(i, path, result)
            path.pop()

        leaves = set(self.getOutputStates())
        result = []

        for root in self.rootStates:
            preOrderDFS(root, [], result)
        return result

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Modifying functions # - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # needed for union (and testing) - name collision resolving
    def renameState(self, oldName: str, newName: str):
        # renaming state in rootStates array (1st layer)
        if oldName in self.rootStates:
            self.rootStates.remove(oldName)
            self.rootStates.append(newName)

        if oldName not in self.transitions:
            return
        # supposing only one state with the oldName exists in treeAut
        # renaming state in the dictionary of states (1st layer)
        self.transitions[newName] = self.transitions.pop(oldName)

        # renaming name of the state inside transitions (2nd layer)
        for edge in transitions(self):
            if edge.src == oldName:
                edge.src = str(newName)
            # renaming state name inside the children array (3rd layer)
            for i in range(len(edge.children)):
                if edge.children[i] == oldName:
                    edge.children[i] = newName

    def removeState(self, state: str):
        if state in self.rootStates:
            self.rootStates.remove(state)

        if state in self.transitions:
            self.transitions.pop(state)

        for content in self.transitions.values():
            keysToDelete = []
            for key, edge in content.items():
                if state in edge.children:
                    keysToDelete.append(key)
            for key in keysToDelete:
                content.pop(key)

    def removeTransition(self, state: str, key: str):
        if state not in self.transitions:
            return
        if key not in self.transitions[state]:
            return
        self.transitions[state].pop(key)

    # Creates a better readable state names for more clear images (DOT).
    # Useful after unfolding, determinization/normalization, etc.
    def reformatStates(self, prefix='q', startFrom=0, verbose=False):
        temp = {}
        i = startFrom
        for state in iterateBFS(self):
            if state not in temp:
                temp[state] = i
                i += 1
        for state, idx in temp.items():
            self.renameState(state, f"temporaryName{idx}")
        for idx in temp.values():
            self.renameState(f"temporaryName{idx}", f"{prefix}{idx}")

    def reformatKeys(self, prefix='k'):  # k as in 'key'
        counter: int = 1  # for no collisions
        for state in iterateBFS(self):
            swap = [key for key in self.transitions[state].keys()]
            for oldKey in swap:
                newKey = f"{prefix}{counter}"
                counter += 1
                self.transitions[state][newKey] = self.transitions[state].pop(oldKey)

    # Shrinks the tree automaton
    # such that it only contain the states from list (reachable states)
    def shrinkTA(self, reachable: list):
        toDelete = [x for x in self.rootStates if x not in reachable]
        for stateName, content in self.transitions.items():
            if stateName not in reachable:
                toDelete.append(stateName)
            for edge in content.values():
                if edge.src not in reachable:
                    toDelete.append(edge.src)
                for i in edge.children:
                    if i not in reachable:
                        toDelete.append(i)

        for i in set(toDelete):
            self.removeState(i)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Building functions #  - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # Prefix, suffix and infix creation was initially thought of as a means
    # of obtaining a partial order over the box alphabet.
    # Creating a total order over the box alphabet is necessary for canonical
    # form of folding/unfolding algorithms.

    def createPrefix(self, additionalOutputEdges):
        result = copy.deepcopy(self)

        result.name = f"prefix({self.name}, {additionalOutputEdges})"

        for stateName, content in result.transitions.items():
            tempDict = {}
            if stateName in self.rootStates:
                continue
            for symbol in additionalOutputEdges:
                tempString = str(stateName) + "-" + str(symbol) + "-()"
                tempDict[tempString] = TTransition(stateName, TEdge(symbol, [], ""), [])
            for tempName, tempEdge in tempDict.items():
                # checking for non-port output edge
                nonPortOutput = False
                for edge in content.values():
                    label = edge.info.label
                    if not label.startswith('Port') and len(edge.children) == 0:
                        nonPortOutput = True
                # skip adding non-port output edge
                # if another non-port output present
                if not tempEdge.info.label.startswith('Port') and nonPortOutput:
                    continue
                else:
                    content[tempName] = tempEdge
        result.portArity = result.getPortArity()
        return result

    def createSuffix(self):
        result = copy.deepcopy(self)
        result.name = f"suffix({result.name})"
        for stateName, edgeDict in result.transitions.items():
            check = True
            for edge in edgeDict.values():
                edgeLabel = edge.info.label
                if (edgeLabel.startswith("Port")):
                    check = False
                    break
            if check and stateName not in result.rootStates:
                result.rootStates.append(stateName)
        return result

    def createInfix(self, additionalOutputEdges):
        result = copy.deepcopy(self)
        ports = [sym for sym in additionalOutputEdges
                 if (sym.startswith("Port")
                     and sym not in result.getOutputSymbols())]
        result.name = f"infix({self.name}, {ports})"

        for state in result.getStates():
            # A) make all states rootstates
            if state in result.rootStates:
                continue
            result.rootStates.append(state)

            # B) add output ports from additionalOutputEdges to every state
            for i in ports:
                key = f"{state}-{i}->()"
                edge = [state, TEdge(i, [], ""), []]
                result.transitions[state][key] = edge
        result.portArity = result.getPortArity()
        return result


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# ITERATORS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# custom iterator - yields only edges (no keys)
#  for cleaner code
def transitions(obj) -> TTransition:
    dictObj = obj
    if isinstance(obj, TTreeAut):
        dictObj = obj.transitions

    for innerObj in dictObj.values():
        if isinstance(innerObj, dict):
            for edge in transitions(innerObj):
                yield edge
        else:
            yield innerObj


# def transitionsWithKeys(obj):
#     dictObj = obj
#     if isinstance(obj, TTreeAut):
#         dictObj = obj.transitions

#     for key, innerObj in dictObj.items():
#         if isinstance(innerObj, dict):
#             for edge in transitionsWithKeys(innerObj):
#                 yield key, edge
#         else:
#             yield innerObj


def transitionsFrom(obj, state):
    dictObj = obj
    if isinstance(obj, TTreeAut):
        for edge in dictObj.transitions[state].values():
            yield edge


# Depth-first search iterator over states of a tree automaton
def iterateDFS(ta: TTreeAut):
    stack = [root for root in ta.rootStates]
    stack.reverse()
    visited = set()
    while stack:
        state = stack.pop()
        if state in visited:
            continue
        visited.add(state)
        yield state
        for edge in ta.transitions[state].values():
            for child in edge.children:
                if child not in visited:
                    stack.append(child)


# Breadth-first search iterator over states of a tree automaton
def iterateBFS(ta: TTreeAut):
    queue = [root for root in ta.rootStates]
    visited = set()
    while queue:
        state = queue.pop(0)
        if state in visited:
            continue
        visited.add(state)
        yield state
        for edge in ta.transitions[state].values():
            for child in edge.children:
                if child not in visited:
                    queue.append(child)

class TTreeAutMetaData:
    """Contains string lengths for tidy formatting (tables, etc.).
    """
    def __init__(self, ta: TTreeAut):
        self.ta: TTreeAut = ta

        self.state: int = 0
        self.child: int = 0
        self.key: int = 0
        self.variable: int = 0
        self.label: int = 0
        self.edge: int = 0
        self.boxName: int = 0
        self.arity: int = 0

        self.keyPrefix: int = 0
        self.statePrefix: int = 0
        self.variablePrefix: int = 0

    def __repr__(self):
        return (
            f"[TTreeAutMetaData]\n" +
            f"Max State Length        = {self.state}\n" +
            f"Max Child Length        = {self.child}\n" +
            f"Max Key Length          = {self.key}\n" +
            f"Max Variable Length     = {self.variable}\n" +
            f"Max Edge Label Length   = {self.label}\n" +
            f"Max Box Name Length     = {self.boxName}\n"
        )

    def recompute(self):
        def getPrefixLength(string: str) -> int:
            prefixLen = 0
            for i in range(len(string)):
                if not string[i:].isnumeric():
                    prefixLen += 1
            return prefixLen
        
        prefixesSet = False
        for edgeDict in self.ta.transitions.values():
            for key, edge in edgeDict.items():
                self.state = max(self.state, len(edge.src))
                self.label = max(self.label, len(edge.info.label))
                self.variable = max(self.variable, len(edge.info.variable))
                self.key = max(self.key, len(key))
                self.edge = max(self.edge, len(str(edge.info)))

                if edge.info.variable != "" and not prefixesSet:
                    self.keyPrefix = getPrefixLength(key)
                    self.statePrefix = getPrefixLength(edge.src)
                    self.variablePrefix = getPrefixLength(edge.info.variable)
                    prefixesSet = True

                for box in edge.info.boxArray:
                    if type(box) == str:
                        self.boxName = max(self.boxName, len(box))
                    if type(box) == TTreeAut:
                        self.boxName = max(self.boxName, len(box.name))
                for child in edge.children:
                    self.child = max(self.child, len(child))
                
        for arity in self.ta.getSymbolArityDict().values():
            self.arity = max(self.arity, arity)

# End of file ta_classes.py
