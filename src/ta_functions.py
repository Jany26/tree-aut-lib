# ta_functions.py
# Basic functions for working with tree automata (from taLib.py)
# Implementation of tree automata for article about automata-based BDDs
# Author: Jany26  (Jan Matufka)  <xmatuf00@stud.fit.vutbr.cz>

# from os import stat
# from re import L
from ta_classes import *
from itertools import product

from typing import Tuple
import copy

## All operations for tree automata (TA) implemented in this module:
# - match(TA, tree) - checks whether a tree can be generated by a tree automaton
# - determinize(TA) - creates a deterministic (and complete) tree automaton from a NTA
# - union(TA1, TA2)
# - intersection(TA1, TA2)
# - complement(TA)
# - removeUselessStates(TA) - removes unreachable states from a TA
# - nonEmptinessCheck(TA) - checks whether a TA can generate non-empty set of trees
# - generateWitness(TA) - creates an example of a tree generated by the TA (if possible)

# MAYBE TODO
# - compareTwoBoxes(TA1, TA2)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# SUBFUNCTIONS / HELPER FUNCTIONS
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Helper function for bottom-up tree parsing 
# - (determinization, reachability, nonEmptiness)

## Creates all possible variations (with repetition) of items 
#  from list of "parents" of a given length ("size"),
#  such that the variation (stored in a list) contains the "state" item at least once
#  note: assumes, that the "state" is in parents "list"
def generatePossibleChildren(state:str, parents:list, size:int) -> list:
    possibilites = product(parents, repeat = size)
    result = []
    for k in possibilites:
        if state in k:
            result.append(list(k))
    return result

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Non emptiness check (+ witness generation) helper functions

## Helper function for generating tree starting from a specified node
# uses a dictionary of transitions (only 1 needed for each state)
def generateWitnessTree(edgeDict:dict, root:str) -> TTreeNode:
    if (type(edgeDict) is None or type(root) is None):
        return None
    if len(edgeDict[root][2]) == 0:
        return TTreeNode(f"({edgeDict[root][1].label};{root})")
    else:
        tempNode = TTreeNode(f"({edgeDict[root][1].label};{root})")
        for i in edgeDict[root][2]:
            tempChild = generateWitnessTree(edgeDict, i)
            tempNode.connectChild(tempChild)
        return tempNode

## Helper function for generating a string that represents a tree, starts from root
# uses dictionary of transitions (only 1 needed for each state)
def generateWitnessString(edgeDict:dict, root:str) -> str:
    if len(edgeDict[root][2]) == 0:
        return str(edgeDict[root][1].label)
    else:
        parentString = str(edgeDict[root][1].label) + "["
        for i in range(len(edgeDict[root][2])):
            childString = generateWitnessString(edgeDict, edgeDict[root][2][i])
            parentString += childString
            if i < len(edgeDict[root][2]) - 1:
                parentString += ";"
        return parentString + "]"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# BASIC OPERATIONS ON TREE AUTOMATA
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Logical equivalent to function accept(DFA, string)
# works recursively, as all children from array have to be matched
def matchTreeTD(ta:TTreeAut, root:TTreeNode) -> bool:

    ## Helper function for matchTreeTD  - - - - - - - - - - - - - - - - - - - -

    def matchTopDown(ta:TTreeAut, node:TTreeNode, state:str) -> bool:
        descendantTuples = []

        for stateName, edge in ta.transitions.items():
            for data in edge.values():
                if stateName == state and node.value == data[1].label:
                    descendantTuples.append(data[2])
        
        for tuple in descendantTuples:
            b = True
            # when tree unexpected amount children than expected
            if len(tuple) != len(node.children):
                break
            for i in range(len(tuple)):
                # recursive matching for all children
                b = matchTopDown(ta, node.children[i], tuple[i])
                if not b:
                    break
            if b:
                return True
        return False

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    for rootPtr in ta.rootStates:
        if matchTopDown(ta, root, rootPtr) == True:
            return True
    return False

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Logical equivalent to function accept(DFA, string)
# works recursively, but starts the matching process from the leaves
# instead of starting from the root
def matchTreeBU(ta:TTreeAut, root:TTreeNode) -> bool:

    ## Helper function for matchTreeBU  - - - - - - - - - - - - - - - - - - - -

    def matchBottomUp(ta:TTreeAut, root:TTreeNode) -> list:
        result = []
        if len(root.children) == 0:
            for stateName, edge in ta.transitions.items():
                for data in edge.values():
                    if (
                        data[1].label == root.value # or symbol
                        and len(data[2]) == 0
                        and stateName not in result
                    ):
                        result.append(stateName)
            return result

        else:
            childrenSymbols = []
            for i in range(len(root.children)):
                childrenSymbols.append(matchBottomUp(ta, root.children[i]))
            for stateName, edge in ta.transitions.items():
                for data in edge.values():
                    if data[1].label == root.value: # or symbol
                        x = True
                        for i in range(len(data[2])):
                            if data[2][i] not in childrenSymbols[i]:
                                x = False
                                break
                        if x:
                            result.append(stateName)
            return result
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    result = matchBottomUp(ta, root)
    temp = []
    for value in result:
        if value in ta.rootStates:
            temp.append(value)
    return len(temp) != 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Helper functions for BU-determinization - - - - - - - - - - - - - - - - - 

def detCreateName(stateList:list) -> str:
    stateList.sort()
    result = "{"
    for i in stateList:
        result += str(i) + ","
    return result.rstrip(",") + "}"

def detCreateLookupDict(ta:TTreeAut, alphabet) -> dict:
    result = {symbol:{} for symbol in alphabet}
    for edges in ta.transitions.values():
        for edge in edges.values():
            symbol = edge[1].label
            
            if str(edge[2]) not in result[symbol]:
                result[symbol][str(edge[2])] = []

            if edge[0] not in result[symbol][str(edge[2])]:
                result[symbol][str(edge[2])].append(edge[0])
    return result

def detGenerateTuples(stateList:list, state:list, size:int) -> list:
    cartProd = product(stateList, repeat = size)
    return [ [j for j in i if len(i) == size] for i in cartProd if state in i ]

def detOutEdges(outEdges:list, doneEdges, alphabet):
    result = []
    for symbol in outEdges:
        doneEdges.append([ outEdges[symbol], symbol, [] ])
        result.append(outEdges[symbol])

    for symbol in alphabet:
        if symbol not in outEdges and alphabet[symbol] == 0:
            doneEdges.append([ [], symbol, [] ])
            if [] not in result:
                result.append([])
    return result, copy.deepcopy(result)

def detChildHandle(tuple:list, lookup:dict) -> list:
    children = [list(i) for i in product(*tuple)]
    result = []
    for i in children:
        if str(i) not in lookup: 
            continue
        for j in lookup[str(i)]:
            if j in result: 
                continue
            result.append(j)
    result.sort()
    return result

def detCreateRelation(edgeList:list, alphabet:dict) -> dict:
    edgeDict = {}
    # print(f"> ALPHABET\n{alphabet}")
    for edge in edgeList:
        # print(f"  > EDGE = {edge}")
        source = detCreateName(edge[0])
        symbol = TEdge(edge[1], [None] * alphabet[str(edge[1])], "") 
        # print(f"    > SRC = {source}")
        # print(f"    > SYM = {edge[1]}")
        # print(f"    > CHI = {edge[2]}")
        children = [detCreateName(i) for i in edge[2]]
        key = f"{source}-{edge[1]}->({children})"
        if source not in edgeDict:
            edgeDict[source] = {}
        edgeDict[source][key] = [source, symbol, children]
    return edgeDict

def detCreateRoots(doneStates:list, roots:list) -> list:
    result = []
    for doneSet in doneStates:
        for root in roots:
            if root in doneSet:
                temp = detCreateName(doneSet)
                if temp not in result:
                    result.append(temp)
    return result

## Creates a deterministic and complete version of the "ta" tree automaton with regards to the "alphabet"
#  alphabet is a dictionary -> key = "symbol", value = arity (integer)
#  doneStates = list of macrostates (macrostate = list of states/strings)
#  doneTransitions = dictionary of transitions, key is just some string created from doneStates by a function
#       - each key references a list/dict of all possible transitions
#  the transitions themselves look like this: [ parentMacroState, symbol, childMacroStateList ]
#       - parentMacroState = list of states
#       - symbol = 
#       - childMacroStateList = list of lists of states 
#           - from which the states in parentMacroState can be reached through an edge labeled with the symbol
#
#  * IMPORTANT NOTE = doneStates and doneTransitions are just placeholder structures
#       - in the final automaton the macroStates (list/set of states) will be represented by a string
#       - this string is created using makeNameFromSet() function
def treeAutDeterminization(ta:TTreeAut, alphabet:dict, verbose=False) -> TTreeAut:

    parentLookup = detCreateLookupDict(ta, alphabet)
    doneTuples = {symbol:{} for symbol in alphabet}
    doneEdges = []
    workSet, doneSet = detOutEdges(ta.getOutputEdges(), doneEdges, alphabet)
    
    if verbose:
        print("workset   = {workSet}")
        print("doneset   = {doneSet}")
        print("doneedges = {doneEdges}")
        print("{:<120} {:<20} {:<60} {:<5} {:<5} {:<30}".format("children", "symbol", "current", "work", "done", "function"))
        print("-" * 214)
        counter = 0
    while workSet != []:
        state = workSet[0]
        workSet.remove(state)
        doneSet.append(state)
        for symbol, arity in alphabet.items():
            lookup = parentLookup[symbol]
            if lookup == {}:
                # TODO: HANDLE UNUSED SYMBOL
                pass
            combinations = detGenerateTuples(doneSet, state, arity)
            for tuple in combinations:
                # print(combinations)
                if str(tuple) in doneTuples[symbol]:
                    continue
                if verbose: 
                    counter += 1
                    print("{:<120} {:<20} {:<60} {:<5} {:<5} {:<30}".format(
                        f"{counter}) {tuple}"[:120], symbol[:20], str(state)[:60], len(workSet), len(doneSet), f"det({ta.name})"
                    ))
                parents = detChildHandle(tuple, lookup)
                doneTuples[symbol][str(tuple)] = parents
                if parents not in workSet:
                    workSet.append(parents)
                doneEdges.append([ parents, symbol, tuple ])
    
    newRoots = detCreateRoots(doneSet, ta.rootStates)
    newEdges = detCreateRelation(doneEdges, alphabet)
    result = TTreeAut(newRoots, newEdges, f"determinized({ta.name})")
    result.portArity = result.getPortArity()
    
    if verbose: print(f"determinization of {ta.name} done")
    
    return result
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Creates a tree automaton, that generates trees which can be generated by 
#  at least one of its two input automatons.
# 
#  just merging transition dictionaries and set of rootstates
#  before merging, name resolution is needed for states with the same name
def treeAutUnion(ta1:TTreeAut, ta2:TTreeAut) -> TTreeAut:
    result = copy.deepcopy(ta2)
    result.name = f"union({ta1.name},{ta2.name})"

    # remove name collisions by renaming states in a new automaton
    for stateName in ta1.transitions:
        if stateName in result.transitions:
            result.renameState(stateName, str(stateName) + "_new")
    
    # merge the two automata
    result.transitions = {**result.transitions, **ta1.transitions}
    result.rootStates = result.rootStates + ta1.rootStates
    result.portArity = result.getPortArity()
    return result

## Creates a tree automaton, that only generates trees which can be generated by
#  both its input automatons.
def treeAutIntersection(ta1:TTreeAut, ta2:TTreeAut, verbose=False) -> TTreeAut:
    ## Helper function, creates a pair key, [edgeInfo] for TAinteresction()
    #  based on the two keys and two edges from input.
    #  If possible, adds a new transition into the result dictionary
    counter = 0
    def handleIntersectionEdge(k1, e1, k2, e2, result:TTreeAut, state:str, counter):
        newKey = f"({k1},{k2})" # merge transition keys 
        newState = f"({e1[0]},{e2[0]})" # merge source state names
        # e.g. states 'q1' and 'q2' create '(q1, q2)'
        newEdge = copy.deepcopy(e1[1]) # new edge with same info
        newChildStates = [] # merged children
        for i in range(len(e1[2])):
            newChildStates.append(f"({e1[2][i]},{e2[2][i]})")

        if verbose:
            print("{:<60} {:<40} {:<40}   |   {:<40}".format(
                f"{counter}) handling state {state}"[:60],
                f"{k1}"[:40],
                # f"{e1}"[:20],
                f"{k2}"[:40],
                # f"{e2}"[:20],
                f"{result.name}"
            ))

        if state not in result.transitions:
            result.transitions[state] = {}
        # add transition to transitions in a state dictionary
        # if verbose: print(newKey)
        result.transitions[state][newKey] = [newState, newEdge, newChildStates]
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # NOTE: consider how to handle not-matching ports
    # label1 = transition1[1].label
    # label2 = transition2[1].label
    # if (label1.startswith("Port") and label2.startswith("Port") and label1 != label2):
    #     doWhatever()
    #     pass

    # NOTE: consider port adding (differentiating ports - maybe by some counter)
    # if transition1[1].startswith("Port"):
    #     newTransition.append("Port") 
    # else:
    #     newTransition.append(transition1[1])

    result = TTreeAut([], {}, f"int({ta1.name},{ta2.name})")
    for stateName1, edgeDict1 in ta1.transitions.items():
        for stateName2, edgeDict2 in ta2.transitions.items():
            newStateName = f"({stateName1},{stateName2})"
            if stateName1 in ta1.rootStates and stateName2 in ta2.rootStates:
                result.rootStates.append(newStateName)
            for k1, e1 in edgeDict1.items(): # key1, edge1
                for k2, e2 in edgeDict2.items(): # key2, edge2
                    if len(e1[2]) != len(e2[2]): # arity consistency
                        continue
                    if e1[1].label != e2[1].label: # symbol consistency
                        continue
                    counter += 1
                    handleIntersectionEdge(k1, e1, k2, e2, result, newStateName, counter)

    result.portArity = result.getPortArity()
    result.name = f"intersection({ta1.name},{ta2.name})"
    return result

## creates a tree automaton that can only generate trees, that cant be generated by the input TA
#  uses determinization and completion of the TA beforehand
def treeAutComplement(ta:TTreeAut, alphabet:dict, verbose=False) -> TTreeAut:
    result = treeAutDeterminization(ta, alphabet, verbose)
    roots = [i for i in result.getStates() if i not in result.rootStates]
    result.rootStates = roots
    result.name = f"complement({ta.name})"
    return result

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Returns a "witness tree" if the tree automaton has non empty tree "language"
# Witness tree is just an example of most trivial trees generated by this automaton.
# If the TA has empty language, a tuple (None, "") is returned
# meaning the tree automaton can generate at least one tree
# returns a trivial example of a tree generated by the tree automaton and its string representation
# if the language is empty, None and empty string is returned
def nonEmptyTD(ta:TTreeAut, verbose=False) -> Tuple[TTreeNode, str]:
        
    def nonEmptyTDinitFunc(ta:TTreeAut) -> Tuple[dict, dict]:
        edgeLookup = {}
        outDict = {}
        for outSymbol, stateList in ta.getOutputEdges().items():
            for state in stateList:
                if state in edgeLookup:
                    continue
                outDict[state] = True
                edgeLookup[state] = [ state, TEdge(outSymbol, [], ""), [] ]

        return edgeLookup, outDict
    
    def debugOutput(outDict, edgeLookup):
        trueList = []
        falseList = []
        for state, value in outDict.items():
            trueList.append(state) if value else falseList.append(state)
        print(f"  TRUE -> {trueList}")
        print(f"  FALSE -> {falseList}")
        for state, edge in edgeLookup.items():
            print(f"  {state} -> {edge}")

    ## Returns True if the state from a tree automaton can generate output (in finite amount of steps)
    #  uses top-down approach and thus backtracking, which requires a stack for remembering visited states
    #  as the tree is being parsed, edge lookup dictionary is being filled, 
    #    - this dictionary is then used in witness generation (example of a tree generated by the TA)
    def outputSearchTD(ta:TTreeAut, state:str, callStack:list, outDict:dict, edgeLookup:dict, debug, total) -> bool:
        if ( 
            state in callStack # breaking endless recursion
            or state not in ta.transitions # skipping if state has no entry
            or len(ta.transitions[state]) == 0 # skipping if state has an empty entry
        ):
            # if debug: print("    > FALSE ... self-loop or invalid state")
            if debug: print("{:<80} {:<10} {:<50} {:<20}".format(
                f"checking {state}", 
                f"-> SKIP", 
                f"loop-break or missing data", 
                f"neTD({ta.name})"
            ))
            return False
        
        if debug: 
            print("{:<60} {:<120} {:<12} {:<20}".format(
                f"state " + "-" * 54, f"callStack " + "-" * 108, f"done", f"function"
            ))
            print("{:<60} {:<120} {:<12} {:<20}".format(
                f"{state}"[:60], 
                f"{callStack}"[:120], 
                f"{len(outDict)}/{total}", 
                f"neTD({ta.name})"
            ))
        
        for edge in ta.transitions[state].values():
            # skipping self-looping transitions
            if state in edge[2]:
                continue
            outputReachable = True
            for child in edge[2]:
                # checking if the state has been already visited and we know if its OK
                if child in outDict:
                    if outDict[child]:
                        if debug: 
                            print("{:<80} {:<10} {:<50} {:<20}".format(
                                f"checking {state}", 
                                f"-> TRUE", 
                                f"direct | parent = {state}", 
                                f"neTD({ta.name})"
                            ))
                        continue
                    else:
                        if debug: 
                            print("{:<80} {:<10} {:<50} {:<20}".format(
                                f"checking {state}", 
                                f"-> FALSE", 
                                f"direct | parent = {state}", 
                                f"neTD({ta.name})"
                            ))
                        outputReachable = False
                        break
                # we dont know anything about the state = 
                callStack.append(state)
                # print(f"checking {child} -> ??? GOING DEEPER")
                outputReachable = outputSearchTD(ta, child, callStack, outDict, edgeLookup, debug, total)
                callStack.remove(state)
                # skipping NOT OK transition
                if not outputReachable:
                    break
            
            # found an OK transition
            if outputReachable:
                if debug:
                    l = len(callStack)
                    print("{:<80} {:<10} {:<50} {:<20}".format(
                        f"checking {state}", 
                        f"-> TRUE", 
                        f"recursion | parent = {callStack[l-1]}" if l > 0 else "root",
                        f"neTD({ta.name})"
                    ))
                outDict[state] = True
                edgeLookup[state] = edge
                # callStack.remove(state)
                return True
        
        if debug:
            l = len(callStack)
            print("{:<80} {:<10} {:<50} {:<20}".format(
                f"checking {state}", 
                f"-> FALSE", 
                f"recursion | parent = {callStack[l-1]}" if l > 0 else "root",
                f"neTD({ta.name})"
            ))
        outDict[state] = False
        
        # callStack.remove(state)
        return False

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    
    total = len(ta.getStates()) # for debug
    edgeLookup, outDict = nonEmptyTDinitFunc(ta)
    for root in ta.rootStates:
        if outputSearchTD(ta, root, [], outDict, edgeLookup, verbose, total):
            if verbose: print(f"{ta.name} has non-empty lang")
            return generateWitnessTree(edgeLookup, root), generateWitnessString(edgeLookup, root)
    if verbose: print(f"{ta.name} has empty lang")
    return None, ""


## Bottom-up version of non empty language check
#  starts the mock tree generation from the leaves (states with output transitions)
#  same signature as top-down version
def nonEmptyBU(ta:TTreeAut, verbose=False) -> Tuple[TTreeNode, str]:
    if verbose:
        print("{:<60} {:<20} {:<20} {:<20} {:<20} {:<20}".format(
            "state", "symbol", "workset", "doneset", "allstates", "function"
        ))
        print("-" * 150)
        counter = 0

    # initialization phase (finding all output )
    workList = ta.getOutputStates()
    size = len(ta.getStates())
    done = {}
    doneSet = ta.getOutputStates()
    arityDict = ta.getSymbolArityDict()
    for state in workList:
        for edge in ta.transitions[state].values():
            if len(edge[2]) == 0:
                done[state] = edge

    def doneEdgePrint(doneEdges:dict):
        result = []
        for i in doneEdges.values():
            result.append( [ i[0], i[1].label, i[2] ] )
        for j in result:
            print(j)
        print()

    # tree automaton bottom-up parsing phase
    while len(workList) != 0:
        state = workList[0]
        workList.remove(workList[0])
        if state not in doneSet: 
            doneSet.append(state)
        if state in ta.rootStates:
            if verbose: print(f">> {ta.name} has non-empty lang")
            return generateWitnessTree(done, state), generateWitnessString(done, state)
        for symbol in arityDict:
            arity = arityDict[symbol]
            if arity == 0:
                continue
            allPossibleTuples = generatePossibleChildren(state, list(done), arity)
            if verbose: 
                counter += 1
                print("{:<60} {:<20} {:<20} {:<20} {:<20} {:<20}".format(
                    f"{counter}) {state}", 
                    f"{symbol}", 
                    f"{len(workList)}", 
                    f"{len(doneSet)}", 
                    f"{size}",
                    f"neBU({ta.name})"
                ))
            for stateName, edgeDict in ta.transitions.items():
                for edge in edgeDict.values():
                    if (
                        edge[1].label != symbol
                        or edge[2] not in allPossibleTuples
                    ):
                        continue
                    if stateName not in done:
                        workList.append(stateName)
                        done[stateName] = edge

    if verbose: print(f">> {ta.name} has empty lang")
    return None, ""

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Searches the tree from bottom-up and from top-down, removing unreachable states
def removeUselessStates(ta:TTreeAut) -> TTreeAut:
    workTA = copy.deepcopy(ta)
    reachableStatesBU = reachableBU(workTA)
    workTA.shrinkTA(reachableStatesBU)
    reachableStatesTD = reachableTD(workTA)
    workTA.shrinkTA(reachableStatesTD)
    return workTA

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Generates a list of states reachable from the root states
def reachableTD(ta:TTreeAut) -> list:
    workList = copy.deepcopy(ta.rootStates)
    result = copy.deepcopy(ta.rootStates)

    while len(workList) > 0:
        state = workList.pop()
        if state not in ta.transitions:
            continue
        edgeDict = ta.transitions[state]
        for edge in edgeDict.values():
            for i in edge[2]:
                if i not in result:
                    workList.append(i)
                    result.append(i)
    return result

## Generates a list of states reachable from the leaf states
def reachableBU(ta:TTreeAut) -> list:
    workList = ta.getOutputStates()
    result = ta.getOutputStates()
    arityDict = ta.getSymbolArityDict()
    while len(workList) > 0:
        state = workList.pop()
        for symbol, arity in arityDict.items():
            if arity <= 0:
                continue
            allPossibileTuples = generatePossibleChildren(state, result, arity)
            for stateName, edgeDict in ta.transitions.items():
                for edge in edgeDict.values():
                    if (
                        edge[1].label != symbol
                        or edge[2] not in allPossibileTuples
                    ):
                        continue
                    if stateName not in result:
                        workList.append(stateName)
                        result.append(stateName) # similarly for dictionary
    return result

## One of the rule-checks for a well-defined tree automaton (box).
#  Implements bottom-up search and keeps information about all reachable port
#  combinations from a given state.
#
#  Each root state has to be able to reach a precise amount of ports, which is
#  given by TAs port-arity.
def portConsistencyCheck(ta:TTreeAut) -> bool:

    ## Helper function, creates a list of sets, 
    # which correspond to all possible reachable combinations of ports
    # (or output symbols) from a given list of states.
    # Also takes a current state of port dictionary for looking up data.
    #
    #   - portDict = dictionary of reachable ports from each state
    #   - stateList = list of states, from which reachable ports are searched
    def createPortSet(portDict:dict, stateList) -> set:
        allSetLists = []
        for i in stateList:
            allSetLists.append(portDict[i])
        # create cartesian product of setlists => list of tuples of lists of sets
        tupleList = product(allSetLists, repeat=len(allSetLists)) 
        result = []
        for tuple in tupleList: # iterate over each tuple of lists of sets
            for setList in tuple: # iterate over each list of sets:
                unionSet = set() # create union of each small set from the setlist
                for unitSet in setList: # iterate over each set
                    unionSet |= unitSet 
                if unionSet not in result:
                    result.append(unionSet)
        return result
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

    # initialization phase
    worklist = ta.getOutputStates()
    done = {}
    arityDict = ta.getSymbolArityDict()
    for symbol, stateList in ta.getOutputEdges().items():
        if not symbol.startswith("Port"):
            continue
        for state in stateList:
            if state not in done:
                done[state] = []
            if symbol not in done[state]:
                done[state].append(set([symbol]))
    
    # bottom-up parsing phase
    while len(worklist) > 0:
        state = worklist.pop()
        if state in ta.rootStates and state in done:
            if len(done[state]) != ta.portArity:
                return False
        for symbol, arity in arityDict.items():
            if arityDict[symbol] == 0:
                continue
            allPossibleTuples = generatePossibleChildren(state, list(done), arity)
            for stateName, edgeDict in ta.transitions.items():
                for edge in edgeDict.values():
                    if (
                        edge[1].label != symbol
                        or edge[2] not in allPossibleTuples
                    ):
                        continue
                    if stateName not in done:
                        done[stateName] = []
                        worklist.append(stateName)
                    portSet = createPortSet(done, edge[2])
                    for i in portSet:
                        if i not in done[stateName]:
                            done[stateName].append(i)
    return True

def isWellDefined(ta:TTreeAut, errDisplay=False) -> bool:

    wellDefinedConditions = {
        "1-non-emptiness":True,
        "2-trimness":True,
        "3-port-consistency":True,
        "4-root-uniqueness":True,
        "5-non-vacuity":True,
        "6-port-uniqueness":True,
        "7-unambiguity":True,
    }

    # 1) Non-emptiness  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    witnessTree, witnessString = nonEmptyBU(ta)
    if witnessTree == None or witnessString == "":
        wellDefinedConditions["1-non-emptiness"] = False

    # 2) Trimness - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    allStates = ta.getStates()
    if set(reachableBU(ta)) != set(allStates) or set(reachableTD(ta)) != set(allStates):
        wellDefinedConditions["2-trimness"] = False

    # 3) Port consistency - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    if not portConsistencyCheck(ta):
        wellDefinedConditions["3-port-consistency"] = False

    # 4) Root-uniqueness  - - - - - - - - - - - - - - - - - - - - - - - - - - -
    if len(ta.rootStates) != 1:
        wellDefinedConditions["4-root-uniqueness"] = False

    # 5) Non-vacuity  - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    for i in ta.rootStates:
        rootEdges = ta.transitions[i]
        for edge in rootEdges.values():
            if len(edge[2]) == 0 and edge[1].label.startswith("Port"):
                wellDefinedConditions["5-non-vacuity"] = False

    # 6) Port-uniqueness  - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    outputEdges = ta.getOutputEdges()
    portCounter = 0
    for symbol in outputEdges:
        if symbol.startswith("Port"):
            portCounter += 1
            if len(outputEdges[symbol]) != 1:
                wellDefinedConditions["6-port-uniqueness"] = False
    if portCounter != ta.getPortArity():
        wellDefinedConditions["6-port-uniqueness"] = False
    
    # 7) Unambiguity TODO - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    sth = False
    if sth:
        wellDefinedConditions["7-unambiguity"] = True

    # Final processing  - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    boxIsWellDefined = True
    errorMsg = f"   > isWellDefined('{ta.name}'): failed conditions = "
    for condition, value in wellDefinedConditions.items():
        if value == False:
            errorMsg += f"{condition} "
            boxIsWellDefined = False
    if not boxIsWellDefined and errDisplay:
        print(errorMsg)
    return boxIsWellDefined

def areCommutative(ta1:TTreeAut, ta2:TTreeAut) -> bool:
    suffix = ta1.createSuffix()
    prefix = ta2.createPrefix(ta1.getOutputSymbols())
    intersection = treeAutIntersection(suffix, prefix)
    witnessT, witnessS = nonEmptyBU(intersection)
    return witnessT == None

def areComparable(ta1:TTreeAut, ta2:TTreeAut):
    infix = ta1.createInfix(ta2.getOutputEdges())
    language = {**ta1.getSymbolArityDict(), **ta2.getSymbolArityDict()}
    complement = treeAutComplement(infix, language)
    # complement.printTreeAut()
    intersection = treeAutIntersection(complement, ta2)
    witnessT, witnessS = nonEmptyBU(intersection)
    return witnessT == None

# End of file ta_functions.py
