# ta_classes.py
# Basic classes needed for implementing tree automata
# Implementation of tree automata for article about automata-based BDDs
# Author: Jany26  (Jan Matufka)  <xmatuf00@stud.fit.vutbr.cz>

import copy

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# CLASSES FOR TREE AND TREE AUTOMATON
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Tree node implementation - items generated by tree automata
# tree is made of nodes, root node can be recognized with parent node set to 'None'
# other nodes have a parent, when connected using addChild() and connectChild() methods
#   * attribute 'value' = what is in the node
#   * attribute
class TTreeNode:
    def __init__(self, value):
        self.value = value
        self.parent = None # if None = the node is a root
        self.children = []
        self.depth = 0

    ## Recursively rpints the whole node in somehow structured manner.
    # If called on root node, prints the whole tree
    def printNode(self):
        print(2 * self.depth * ' ' + str(self.value) + "   --> lv " + str(self.depth))
        for i in self.children:
            i.printNode()

    def actualizeDepth(self, newRootDepth:int):
        self.depth = newRootDepth
        for i in self.children:
            i.actualizeDepth(newRootDepth + 1)

    ## Creates a child node with a specific value.
    # Connects the created node to the current node/parent.
    def addChild(self, value):
        childPtr = TTreeNode(value)
        childPtr.parent = self
        childPtr.actualizeDepth(self.depth + 1)
        self.children.append(childPtr)
    
    ## Connects a specific node to current node
    def connectChild(self, node): 
        self.children.append(node)
        node.parent = self
        node.actualizeDepth(self.depth + 1)
    
    ## removes the "leftest" 1 child with specified value.
    def removeChild(self, value): 
        for i in range(len(self.children)):
            if self.children[i].value == value:
                self.children.pop(i)
                return

    def getDepth(self) -> int:
        result = self.depth + 1
        for i in self.children:
            temp = i.getDepth()
            if temp > result: 
                result = temp
        return result

    ### Maybe redundant functions ###

    def findFromLeft(self, valueToFind):
        for i in self.children:
            x = i.findFromLeft(valueToFind)
            if x != None:
                return x
        return self if (self.value == valueToFind) else None

    def findFromRight(self, valueToFind):
        tempList = self.children[::-1]
        for i in tempList:
            x = i.findFromRight(valueToFind)
            if x != None:
                return x
        return self if (self.value == valueToFind) else None



## Edge class (describing the "hyper-edge")
# useful in UBDAs (unreduced binary decision automatons), where it is
# important to store more info about edges
#   * attribute 'variable'
#       - from which variable the edge starts (with the reduction)
#   * attribute 'boxArray'     
#       - which boxes are used over each part of the "hyper-edge"
#       - contains references to boxes which are 
#           used as a means of reduction over this part of the edge
#       - short edges (no box reduction) are just 'None'
#   * attribute 'label'
#       - describes the edge used (usually LH = low-high)
#       - could also be '0' / '1' / 'Port...', which have arity 0
#           * output transitions, states with these can be considered 'leaves'
#
#   * note: length of the boxArray = arity of the edge
class TEdge:
    def __init__(self, label:str, boxArray:list, variable:str):
        self.label = label
        self.boxArray = boxArray
        self.variable = variable

    def __repr__(self):
        result = f"{self.label}"
        if self.variable != "":
            result += f" <{self.variable}>"
        if self.boxArray != []:
            result += f" {self.boxArray}"
        return result
        # tempString = f"{self.label} {{var='{self.variable}'}} , {{"
        # for i in self.boxArray:
        #     tempString += "_," if i == None else str(i + ",")
        #     tempString += " "
        # if len(self.boxArray) > 0:
        #     tempString = tempString[:-2]
        # tempString += "} >"
        # return tempString
        # # return self.label
    # makes the hyper-edge 'short' (all parts of the edge)
    def shortenEdge(self):
        arity = len(self.boxArray)
        self.boxArray = [None] * arity



class TTransition:
    def __init__(self, srcState:str, edge:TEdge, children:list):
        self.srcState = srcState
        self.edge = edge
        self.children = children
    def __repr__(self):
        return f"  > {self.srcState} -- {self.edge} --> {self.children}"

class TState:
    def __init__(self, stateName:str, transDict:dict):
        self.stateName = stateName
        self.transitions = transDict
    def __repr__(self):
        return self.stateName



## Tree automaton class - has two attributes = dictionary of states and root state array
#     transitions = dictionary (A) of dictionaries (B) referenced by state name
#     inner dictionaries (B) are then referenced by transition names (arbitrary)
#     the transition itself is then just a tuple of:
#         - input state, 
#         - edge object (edge label, edge boxes, edge variable label) 
#         - array of output states (size of array = arity of the node)
#     * all state and label names are considered as strings
#
#     In documentation, the naming convention will be:
#     - TTreeAut consists of: array of root states and "state" dictionary 
#     - state dictionaries are referenced by names of the states
#     - each state in the state dictionary references another dictionary
#         - this will be called "transition" dictionary (for the current state)
#         - the transition dictionary is referenced by arbitrary keys (for now)
class TTreeAut:
    def __init__(self, rootStates, transitions, name, portArity=0):
        self.rootStates = rootStates
        self.transitions = transitions
        self.name = name
        self.portArity = self.getPortArity() if portArity == 0 else portArity

    def __repr__(self):
        result = f"  == Name = '{self.name}' (port arity = {self.portArity})\n"
        result += f"  == Root States = {self.rootStates}\n"
        for content in self.transitions.values():
            # result += "  >"
            for edge in content.values():
                result += f"  > {edge[0]} -- {edge[1]} --> {edge[2]}\n"
        return result[:-1] # trim the last '\n'

    def printTreeAut(self):
        print(f"Printing automaton '{self.name}' (port arity = {self.portArity})")
        print("=== Root States ===")
        print(str(self.rootStates))

        for stateName, content in self.transitions.items():
            print("=== State " + stateName + " ===")
            for edge in content.values():
                print(edge[0] + " -- " + str(edge[1]) + " --> " + str(edge[2]))
        print("")

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    ### Informative functions ### - - - - - - - - - - - - - - - - - - - - - - - 
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

    def getStates(self) -> list:
        result = []
        for stateName in self.rootStates:
            result.append(stateName)
        for stateName, edges in self.transitions.items():
            result.append(stateName)
            for data in edges.values():
                for i in data[2]:
                    result.append(i)
        result = list(set(result))
        result.sort()
        return result

    # needed for feeding makePrefix() function
    # generates all edge symbols labeling the output edges from the tree automaton
    def getOutputSymbols(self) -> list:
        outputEdgeList = []
        for transition in self.transitions.values():
            for data in transition.values():
                if len(data[2]) == 0:
                    outputEdgeList.append(data[1].label)
        return outputEdgeList

    # needed for feeding treeAutDeterminize() function
    # generates a dictionary of all output edge symbols which correspond to a list of states,
    # from which the transitions with the specific symbol originate
    def getOutputEdges(self, inverse=False) -> dict:
        result = {}
        for transition in self.transitions.values():
            for data in transition.values():
                if len(data[2]) == 0:
                    if inverse:
                        if data[0] not in result:
                            result[data[0]] = []
                        result[data[0]].append(data[1].label)
                    else:
                        if data[1].label not in result:
                            result[data[1].label] = []
                        result[data[1].label].append(data[0])
        for item in result.values():
            item.sort()
        return result

    # needed for bottom-up reachability -> used in useless state removal
    def getOutputStates(self) -> list:
        outputStateList = []
        for stateName, edges in self.transitions.items():
            for data in edges.values():
                if len(data[2]) == 0:
                    outputStateList.append(stateName)
                    break
        return outputStateList
    
    def getSymbolArityDict(self) -> dict:
        symbolDict = {}
        for edge in self.transitions.values():
            for data in edge.values():
                if data[1].label not in symbolDict:
                    symbolDict[data[1].label] = len(data[2])
        return symbolDict

    def getPortArity(self) -> int:
        portArray = []
        for edge in self.transitions.values():
            for data in edge.values():
                if data[1].label.startswith("Port") and data[1].label not in portArray:
                    portArray.append(data[1].label)
        return len(portArray)
    
    def isTDdeterministic(self) -> bool:
        for edgeDict in self.transitions.values():
            usedSymbols = []
            for edge in edgeDict.values():
                if edge[1].label not in usedSymbols:
                    usedSymbols.append(edge[1].label)
                else:
                    return False
        return True

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    ### Modifying functions ### - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    
    # needed for union (and testing) - name collision resolving
    def renameState(self, oldName:str, newName:str):
        if oldName in self.rootStates:
            self.rootStates.remove(oldName)
            self.rootStates.append(newName)
        
        if oldName not in self.transitions:
            return
        # supposing only one state with the oldName exists in treeAut
        # renaming state in the dictionary of states and rootStates array (1st layer)
        self.transitions[newName] = self.transitions.pop(oldName)

        # renaming name of the state inside transitions (2nd layer)
        for edges in self.transitions.values():
            for data in edges.values():
                if data[0] == oldName:
                    data[0] = str(newName)
                # renaming state name inside the children array (3rd layer)
                for i in range(len(data[2])):
                    if data[2][i] == oldName:
                        data[2][i] = newName

    def removeState(self, state:str):
        if state in self.rootStates:
            self.rootStates.remove(state)
        
        if state in self.transitions:
            self.transitions.pop(state)

        for content in self.transitions.values():
            keysToDelete = []
            for key, transition in content.items():
                if state in transition[2]:
                    keysToDelete.append(key)
            for key in keysToDelete:
                content.pop(key)

    ## Shrinks the tree automaton to only contain the states from list (reachable states)
    def shrinkTA(self, reachable:list):
        toDelete = [x for x in self.rootStates if x not in reachable]
        for stateName, content in self.transitions.items():
            if stateName not in reachable:
                toDelete.append(stateName)
            for data in content.values():
                if data[0] not in reachable:
                    toDelete.append(data[0])
                for i in data[2]:
                    if i not in reachable:
                        toDelete.append(i)

        for i in set(toDelete):
            self.removeState(i)
    
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    ### Building functions ###  - - - - - - - - - - - - - - - - - - - - - - - - 
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

    def createPrefix(self, additionalOutputEdges):
        result = copy.deepcopy(self)
        
        result.name = f"prefix({self.name}, {additionalOutputEdges})"
            
        for stateName, content in result.transitions.items():
            tempDict = {}
            if stateName in self.rootStates:
                continue
            for symbol in additionalOutputEdges:
                tempString = str(stateName) + "-" + str(symbol) + "-()"
                tempDict[tempString] = [stateName, TEdge(symbol, [], ""), []]
            for tempName, tempTransition in tempDict.items():
                # checking for non-port output edge
                nonPortOutput = False
                for transition in content.values():
                    label = transition[1].label
                    if not label.startswith('Port') and len(transition[2]) == 0:
                        nonPortOutput = True
                # skip adding non-port output edge if another non-port output present
                if not tempTransition[1].label.startswith('Port') and nonPortOutput:
                    continue
                else:
                    content[tempName] = tempTransition
        result.portArity = result.getPortArity()
        return result

    def createSuffix(self):
        result = copy.deepcopy(self)
        result.name = f"suffix({result.name})"
        for stateName, edges in result.transitions.items():
            check = True
            for data in edges.values():
                edgeLabel = data[1].label
                if (edgeLabel.startswith("Port")):
                    check = False
                    break
            if check and stateName not in result.rootStates:
                result.rootStates.append(stateName)
        return result

    def createInfix(self, additionalOutputEdges):
        result = copy.deepcopy(self)
        ports = [ sym for sym in additionalOutputEdges 
            if sym.startswith("Port") and sym not in result.getOutputSymbols() ]
        result.name = f"infix({self.name}, {ports})"

        for state in result.getStates():
            # A) make all states rootstates
            if state in result.rootStates:
                continue
            result.rootStates.append(state)
            
            # B) add output ports from additionalOutputEdges to every state
            for i in ports:
                key = f"{state}-{i}->()"
                edge = [state, TEdge(i, [], ""), []]
                result.transitions[state][key] = edge
        result.portArity = result.getPortArity()
        return result

# End of file ta_classes.py
