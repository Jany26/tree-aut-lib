# ta_lib.py
# Basic functions for working with tree automata (from taLib.py)
# Implementation of tree automata for article about automata-based BDDs
# Author: Jany26  (Jan Matufka)  <xmatuf00@stud.fit.vutbr.cz>

from ta_classes import *
from itertools import product

from typing import Tuple
import copy

## All operations for tree automata (TA) implemented in this module:
# - match(TA, tree) - checks whether a tree can be generated by a tree automaton
# - determinize(TA) - creates a deterministic (and complete) tree automaton from a NTA
# - union(TA1, TA2)
# - intersection(TA1, TA2)
# - complement(TA)
# - removeUselessStates(TA) - removes unreachable states from a TA
# - nonEmptinessCheck(TA) - checks whether a TA can generate non-empty set of trees
# - generateWitness(TA) - creates an example of a tree generated by the TA (if possible)

# MAYBE TODO
# - compareTwoBoxes(TA1, TA2)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# SUBFUNCTIONS / HELPER FUNCTIONS
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Helper function for bottom-up tree parsing 
# - (determinization, reachability, nonEmptiness)

## Creates all possible variations (with repetition) of items from list of "parents" of a given length ("size"),
# such that the variation (stored in a list) contains the "state" item at least once
# note: assumes, that the "state" is in parents "list"
def generatePossibleChildren(state:str, parents:list, size:int) -> list:
    possibilites = product(parents, repeat = size)
    result = []
    for k in possibilites:
        if state in k:
            result.append(list(k))
    return result

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

# Non emptiness check (+ witness generation) helper functions

## Helper function for generating tree starting from a specified node
# uses a dictionary of transitions (only 1 needed for each state)
def generateWitnessTree(transitions:dict, root:str) -> TTreeNode:
    if (type(transitions) is None or type(root) is None):
        return None
    if len(transitions[root][2]) == 0:
        return TTreeNode(transitions[root][1].label)
    else:
        tempNode = TTreeNode(transitions[root][1].label)
        for i in transitions[root][2]:
            tempChild = generateWitnessTree(transitions, i)
            tempNode.connectChild(tempChild)
        return tempNode

## Helper function for generating a string that represents a tree, starts from root
# uses dictionary of transitions (only 1 needed for each state)
def generateWitnessString(transitions:dict, root:str) -> str:
    if len(transitions[root][2]) == 0:
        return str(transitions[root][1].label)
    else:
        parentString = str(transitions[root][1].label) + "["
        for i in range(len(transitions[root][2])):
            childString = generateWitnessString(transitions, transitions[root][2][i])
            parentString += childString
            if i < len(transitions[root][2]) - 1:
                parentString += ";"
        return parentString + "]"

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# BASIC OPERATIONS ON TREE AUTOMATA
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Logical equivalent to function accept(DFA, string)
# works recursively, as all children from array have to be matched
def matchTreeTD(ta:TTreeAut, root:TTreeNode) -> bool:

    ## Helper function for matchTreeTD  - - - - - - - - - - - - - - - - - - - -

    def matchTopDown(ta:TTreeAut, node:TTreeNode, state:str):
        descendantTuples = []

        for stateName, edge in ta.transitions.items():
            for data in edge.values():
                if stateName == state and node.value == data[1].label:
                    descendantTuples.append(data[2])
        
        for tuple in descendantTuples:
            b = True
            # when tree unexpected amount children than expected
            if len(tuple) != len(node.children):
                break
            for i in range(len(tuple)):
                # recursive matching for all children
                b = matchTopDown(ta, node.children[i], tuple[i])
                if not b:
                    break
            if b:
                return True
        return False

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    for rootPtr in ta.rootStates:
        if matchTopDown(ta, root, rootPtr) == True:
            return True
    return False

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Logical equivalent to function accept(DFA, string)
# works recursively, but starts the matching process from the leaves
# instead of starting from the root
def matchTreeBU(ta:TTreeAut, root:TTreeNode) -> bool:

    ## Helper function for matchTreeBU  - - - - - - - - - - - - - - - - - - - -

    def matchBottomUp(ta:TTreeAut, root:TTreeNode) -> list:
        result = []
        if len(root.children) == 0:
            for stateName, edge in ta.transitions.items():
                for data in edge.values():
                    if (
                        data[1].label == root.value # or symbol
                        and len(data[2]) == 0
                        and stateName not in result
                    ):
                        result.append(stateName)
            return result

        else:
            childrenSymbols = []
            for i in range(len(root.children)):
                childrenSymbols.append(matchBottomUp(ta, root.children[i]))
            for stateName, edge in ta.transitions.items():
                for data in edge.values():
                    if data[1].label == root.value: # or symbol
                        x = True
                        for i in range(len(data[2])):
                            if data[2][i] not in childrenSymbols[i]:
                                x = False
                                break
                        if x:
                            result.append(stateName)
            return result
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    result = matchBottomUp(ta, root)
    temp = []
    for value in result:
        if value in ta.rootStates:
            temp.append(value)
    return len(temp) != 0

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Creates a deterministic and complete version of the "ta" tree automaton with regards to the "alphabet"
# alphabet is a dictionary -> key = "symbol", value = arity (integer)
# doneStates = list of macrostates (macrostate = list of states/strings)
# doneTransitions = dictionary of transitions, key is just some string created from doneStates by a function
#       - each key references a list/dict of all possible transitions
# the transitions themselves look like this: [ parentMacroState, symbol, childMacroStateList ]
#       - parentMacroState = list of states
#       - symbol = 
#       - childMacroStateList = list of lists of states 
#           - from which the states in parentMacroState can be reached through an edge labeled with the symbol
#
# * IMPORTANT NOTE = doneStates and doneTransitions are just placeholder structures
#       - in the final automaton the macroStates (list/set of states) will be represented by a string
#       - this string is created using makeNameFromSet() functino
def treeAutDeterminization(ta:TTreeAut, alphabet:dict) -> TTreeAut:

    # Helper functions for BU-determinization - - - - - - - - - - - - - - - - - 

    ## Similar function to generatePossibleChildren => instead of generating list of possible states,
    # this function generates list of possible macrostates (list of lists of states)
    def generatePossibleMacroStates(macroStateList:list, macroState:list, size:int) -> list:
        workState = makeNameFromSet(macroState)
        workList = [makeNameFromSet(list) for list in macroStateList]
        possibilities = product(workList, repeat = size)
        
        result = []
        for i in possibilities:
            if workState in i:
                temp = []
                for j in i:
                    temp.append(makeSetFromName(j))
                result.append(temp)
        return result

    ## Searches the tree automaton and returns list of states, 
    # which can produce exact combination of "children" through an edge labeled with "symbol"
    def findPossibleTransitions(ta:TTreeAut, symbol:str, children:list) -> list:
        result = []
        for edges in ta.transitions.values():
            for data in edges.values():
                if data[1].label == symbol and data[2] == children:
                    result.append(data[0])
        result.sort()
        return result

    ## Produces a string from a list of states, which is used as the state label
    # example: ['a', 'b', 'c'] => '{a,b,c}'
    def makeNameFromSet(stateList:list) -> str:
        if len(stateList) == 0:
            return "{}"
        stateList.sort()
        result = "{"
        for i in range(len(stateList)):
            result += str(stateList[i])
            result += ","
        return result.rstrip(",") + "}"

    ## Produces a list of states from a string, which is used as the state label
    # Reverse effect as makeNameFromSet
    def makeSetFromName(name:str) -> list:
        temp = name.lstrip("{").rstrip("}").split(",")
        result = []
        for i in temp:
            result.append(i.strip())
        return result
    
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    doneSet = []
    workSet = []
    doneEdges = []

    outEdges = ta.getOutputEdges()
    for symbol in outEdges:
        doneEdges.append([outEdges[symbol], TEdge(symbol, [], ""), []])
        workSet.append(outEdges[symbol])
        doneSet.append(outEdges[symbol])
    for symbol in alphabet:
        if symbol not in outEdges and alphabet[symbol] == 0:
            doneEdges.append([ [], TEdge(symbol, [], ""), [] ])
            if [] not in workSet:
                workSet.append([])
                doneSet.append([])

    while len(workSet) > 0:
        currentMacroState = workSet.pop()
        for symbol in alphabet:
            arity = alphabet[symbol]
            possibileMacroStateChildren = generatePossibleMacroStates(doneSet, currentMacroState, arity)
            for x in possibileMacroStateChildren:
                possibleNormalChildren = [list(i) for i in product(*x)]
                edge = []
                for i in possibleNormalChildren:
                    reachableMacroState = findPossibleTransitions(ta, symbol, i)
                    if reachableMacroState not in doneSet:
                        doneSet.append(reachableMacroState)
                        workSet.append(reachableMacroState)
                    if edge == []:
                        edge = [reachableMacroState, TEdge(symbol, [None] * arity, ""), x]
                        if edge not in doneEdges:
                            doneEdges.append(edge)

    newRootStates = [makeNameFromSet(q) for q in doneSet for r in ta.rootStates if r in q]

    newTransitions = {}
    for edge in doneEdges:
        stateName = makeNameFromSet(edge[0])
        if stateName not in newTransitions:
            newTransitions[stateName] = {}
        symbol = edge[1]
        children = [makeNameFromSet(i) for i in edge[2]]
        key = f"{stateName}-{symbol.label}->[{children}]"
        newTransitions[stateName][key] = [stateName, symbol, children]

    return TTreeAut(newRootStates, newTransitions, f"determinized({ta.name})")

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Creates a tree automaton, that generates trees which can be generated by 
#  at least one of its two input automatons.
# 
#  just merging transition dictionaries and set of rootstates
#  before merging, name resolution is needed for states with the same name
def treeAutUnion(ta1:TTreeAut, ta2:TTreeAut) -> TTreeAut:
    result = copy.deepcopy(ta2)
    result.name = f"union({ta1.name},{ta2.name})"

    # remove name collisions by renaming states in a new automaton
    for stateName in ta1.transitions:
        if stateName in result.transitions:
            result.renameState(stateName, str(stateName) + "_new")
    
    # merge the two automata
    result.transitions = {**result.transitions, **ta1.transitions}
    result.rootStates = result.rootStates + ta1.rootStates
    return result

## Creates a tree automaton, that only generates trees which can be generated by
#  both its input automatons.
def treeAutIntersection(ta1:TTreeAut, ta2:TTreeAut) -> TTreeAut:
    result = TTreeAut([], {}, f"intersection({ta1.name},{ta2.name})")
    for stateName1, content1 in ta1.transitions.items():
        for stateName2, content2 in ta2.transitions.items():
            newStateName = "(" + stateName1 + "," + stateName2 + ")"
            if stateName1 in ta1.rootStates and stateName2 in ta2.rootStates:
                result.rootStates.append(newStateName)
            for key1, transition1 in content1.items():
                for key2, transition2 in content2.items():
                    newTransition = []
                    # merge transition keys 
                    newKey = "(" + key1 + "," + key2 + ")"

                    # check if the arity is consistent (for now we just assume it is)
                    if len(transition1[2]) != len(transition2[2]):
                        continue
                    
                    # TODO: consider how to handle not-matching ports
                    # if (transition1[1] == transition2[1]) or (transition1[1].startswith("Port") and transition2[1].startswith("Port")):
                    
                    # adding new transition to the intersection if possible
                    if transition1[1] == transition2[1]:

                        # TODO: consider port adding (differentiating ports - maybe by some counter)
                        # newTransition.append("Port") if transition1[1].startswith("Port") else newTransition.append(transition1[1])
                        
                        # merge source state names -> 'q1' with 'q2' create '(q1, q2)'
                        newTransition.append("(" + transition1[0] + "," + transition2[0] + ")")
                        newTransition.append(transition1[1])
                        childStates = []
                        for i in range(len(transition1[2])):
                            childStates.append("(" + transition1[2][i] + "," + transition2[2][i] + ")")
                        newTransition.append(childStates)

                        # add state to transition dictionary 
                        if newStateName not in result.transitions:
                            result.transitions[newStateName] = {}
                        # add transition to transitions in a state dictionary
                        result.transitions[newStateName][newKey] = newTransition
    return result

## creates a tree automaton that can only generate trees, that cant be generated by the input TA
# uses determinization and completion of the TA beforehand
def treeAutComplement(ta:TTreeAut, alphabet) -> TTreeAut:
    result = treeAutDeterminization(ta, alphabet)
    for stateName in result.transitions:
        if stateName in result.rootStates:
            result.rootStates.remove(stateName)
        else:
            result.rootStates.append(stateName)
    return result

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Returns a "witness tree" if the tree automaton has non empty tree "language"
# Witness tree is just an example of most trivial trees generated by this automaton.
# If the TA has empty language, a tuple (None, "") is returned
# meaning the tree automaton can generate at least one tree
# returns a trivial example of a tree generated by the tree automaton and its string representation
# if the language is empty, None and empty string is returned
def nonEmptyTD(ta:TTreeAut) -> Tuple[TTreeNode, str]:

    ## Returns True if the state from a tree automaton can generate output (in finite amount of steps)
    # uses top-down approach and thus backtracking, which requires a stack for remembering visited states
    # as the tree is being parsed, edge lookup dictionary is being filled, 
    #   - this dictionary is then used in witness generation (example of a tree generated by the TA)
    def outputSearchTD(ta:TTreeAut, state:str, stack:list, edgeLookup:dict) -> bool:
        if (
            state in stack
            or state not in ta.transitions
            or len(ta.transitions[state]) == 0
        ):
            return False

        stack.append(state)

        # look for output edges first... at least one is needed to return
        for transition in ta.transitions[state].values():
            if len(transition[2]) == 0:
                stack.pop()
                edgeLookup[state] = transition
                return True

        # no direct  output edge detected, now trying to recursively find output edges
        # trying to generate outputs from all children in at least one transition
        for transition in ta.transitions[state].values():
            b = True
            for i in transition[2]:
                b = outputSearchTD(ta, i, stack, edgeLookup)
                if not b:
                    break
            if b:
                stack.pop()
                edgeLookup[state] = transition
                return True
        stack.pop()
        return False

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

    for root in ta.rootStates:
        edges = {}
        stack = []
        # trying to find an output for each root state (either directly or through children)
        if outputSearchTD(ta, root, stack, edges):
            return generateWitnessTree(edges, root), generateWitnessString(edges, root)
    return None, ""

## Bottom-up version of non empty language check
# starts the mock tree generation from the leaves (states with output transitions)
# same signature as top-down version
def nonEmptyBU(ta:TTreeAut) -> Tuple[TTreeNode, str]:
    # initialization phase (finding all output )
    workList = ta.getOutputStates()
    done = {}
    for state in workList:
        for transition in ta.transitions[state].values():
            if len(transition[2]) == 0:
                done[state] = transition

    # tree automaton bottom-up parsing phase
    while len(workList) != 0:
        state = workList.pop()
        if state in ta.rootStates:
            # return generateTrivialTree(done, state)
            return generateWitnessTree(done, state), generateWitnessString(done, state)
        arityDict = ta.getSymbolArityDict()
        for symbol in arityDict:
            if arityDict[symbol] == 0:
                continue
            allPossibleTuples = generatePossibleChildren(state, list(done), arityDict[symbol])
            for stateName, content in ta.transitions.items():
                for transition in content.values():
                    if (
                        transition[1].label != symbol
                        or transition[2] not in allPossibleTuples
                    ):
                        continue
                    if stateName not in done:
                        workList.append(stateName)
                        done[stateName] = transition
    return None, ""

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Searches the tree from bottom-up and from top-down, removing unreachable states
def removeUselessStates(ta:TTreeAut):
    reachableStatesBU = reachableBU(ta)
    ta.shrinkTA(reachableStatesBU)
    reachableStatesTD = reachableTD(ta)
    ta.shrinkTA(reachableStatesTD)
    return ta

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

## Generates a list of states reachable from the root states
def reachableTD(ta:TTreeAut) -> list:
    workList = copy.deepcopy(ta.rootStates)
    result = copy.deepcopy(ta.rootStates)

    while len(workList) > 0:
        state = workList.pop()
        content = ta.transitions[state]
        for transition in content.values():
            for i in transition[2]:
                if i not in result:
                    workList.append(i)
                    result.append(i)
    return result

## Generates a list of states reachable from the leaf states
def reachableBU(ta:TTreeAut) -> list:
    workList = ta.getOutputStates()
    result = ta.getOutputStates() # dict
    while len(workList) > 0:
        state = workList.pop()
        arityDict = ta.getSymbolArityDict()
        # check for root -> True
        for symbol in arityDict:
            arity = arityDict[symbol]
            if not arity > 0:
                continue
            allPossibileTuples = generatePossibleChildren(state, result, arity)
            for stateName, content in ta.transitions.items():
                for transition in content.values():
                    if (
                        transition[1].label != symbol
                        or transition[2] not in allPossibileTuples
                    ):
                        continue
                    if stateName not in result:
                        workList.append(stateName)
                        result.append(stateName) # similarly for dictionary
    return result

# End of file ta_lib.py
