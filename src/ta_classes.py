# ta_classes.py
# Basic classes needed for implementing tree automata
# Implementation of tree automata for article about automata-based BDDs
# Author: Jany26  (Jan Matufka)  <xmatuf00@stud.fit.vutbr.cz>

import copy

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# CLASSES FOR TREE AND TREE AUTOMATON
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Tree node implementation - items generated by tree automata
# tree is made of nodes,
# root node can be recognized with parent node set to 'None'
# other nodes have a parent,
# when connected using addChild() and connectChild() methods
#   * attribute 'value' = what is in the node
#   * attribute
class TTreeNode:
    def __init__(self, value):
        self.value = value
        self.parent = None  # if None = the node is a root
        self.children = []
        self.depth = 0

    # # Recursively rpints the whole node in somehow structured manner.
    # If called on root node, prints the whole tree
    def printNode(self):
        temp = 2 * self.depth * ' ' + str(self.value)
        print(temp + "   --> lv " + str(self.depth))
        for i in self.children:
            i.printNode()

    def updateDepth(self, newRootDepth: int):
        self.depth = newRootDepth
        for i in self.children:
            i.updateDepth(newRootDepth + 1)

    # # Creates a child node with a specific value.
    # Connects the created node to the current node/parent.
    def addChild(self, value):
        childPtr = TTreeNode(value)
        childPtr.parent = self
        childPtr.updateDepth(self.depth + 1)
        self.children.append(childPtr)

    # # Connects a specific node to current node
    def connectChild(self, node):
        self.children.append(node)
        node.parent = self
        node.updateDepth(self.depth + 1)

    # # removes the "leftest" 1 child with specified value.
    def removeChild(self, value):
        for i in range(len(self.children)):
            if self.children[i].value == value:
                self.children.pop(i)
                return

    def getDepth(self) -> int:
        result = self.depth + 1
        for i in self.children:
            temp = i.getDepth()
            if temp > result:
                result = temp
        return result

    # Maybe redundant functions #

    def findFromLeft(self, valueToFind):
        for i in self.children:
            x = i.findFromLeft(valueToFind)
            if x is not None:
                return x
        return self if (self.value == valueToFind) else None

    def findFromRight(self, valueToFind):
        tempList = self.children[::-1]
        for i in tempList:
            x = i.findFromRight(valueToFind)
            if x is not None:
                return x
        return self if (self.value == valueToFind) else None


# # Edge class (describing the "hyper-edge")
# useful in UBDAs (unreduced binary decision automatons), where it is
# important to store more info about edges
#   * attribute 'variable'
#       - from which variable the edge starts (with the reduction)
#   * attribute 'boxArray'
#       - which boxes are used over each part of the "hyper-edge"
#       - contains references to boxes which are
#           used as a means of reduction over this part of the edge
#       - short edges (no box reduction) are just 'None'
#   * attribute 'label'
#       - describes the edge used (usually LH = low-high)
#       - could also be '0' / '1' / 'Port...', which have arity 0
#           * output transitions, states with these can be considered 'leaves'
#
#   * note: length of the boxArray = arity of the edge
class TEdge:
    def __init__(self, label: str, boxArray: list, variable: str):
        self.label = label
        self.boxArray = boxArray
        self.variable = variable

    def __repr__(self):
        result = f"{self.label}"
        if self.variable != "":
            result += f" <{self.variable}>"
        boxArrayEmpty = True
        for i in self.boxArray:
            if i is not None:
                boxArrayEmpty = False

        if not boxArrayEmpty:
            result += " ["
            for i in self.boxArray:
                result += "_, " if i is None else (
                    f"{i}, " if type(i) == str else f"{i.name}, "
                )
            result = result[:-2]
            result += "]"
        return result

    # makes the hyper-edge 'short' (all parts of the edge)
    def shortenEdge(self):
        arity = len(self.boxArray)
        self.boxArray = [None] * arity


class TTransition:
    def __init__(self, src: str, info: TEdge, children: list):
        self.src = src
        self.info = info  # edge info (symbol, boxes, variable)
        self.children = children

    def __repr__(self):
        # comment = " <<< LEAF TRANSITION >>>" if self.children == [] else ""
        return f"{self.src} -- {self.info} --> {self.children}"


# class TState:
#     def __init__(self, stateName: str, transDict: dict):
#         self.stateName = stateName
#         self.transitions = transDict

#     def __repr__(self):
#         return self.stateName


# # Tree automaton class
# - has two attributes = dictionary of states and root state array
#     transitions = dict (A) of dicts (B) referenced by state name
#     inner dicts (B) are then referenced by transition names (arbitrary)
#     the transition itself is then just a tuple of:
#         - input state,
#         - edge object (edge label, edge boxes, edge variable label)
#         - array of output states (size of array = arity of the node)
#     * all state and label names are considered as strings
#
#     In documentation, the naming convention will be:
#     - TTreeAut consists of: array of root states and "state" dictionary
#     - state dictionaries are referenced by names of the states
#     - each state in the state dictionary references another dictionary
#         - this will be called "transition" dictionary (for the current state)
#         - the transition dictionary is referenced by arbitrary keys (for now)
class TTreeAut:
    def __init__(self, rootStates: list, transitions: dict, name: str, portArity: int = 0):
        self.rootStates = rootStates
        self.transitions = transitions
        self.name = name
        self.portArity = self.getPortArity() if portArity == 0 else portArity

    def __repr__(self):
        result = f"  == Name = '{self.name}' (port arity = {self.portArity})\n"
        result += f"  == Root States = {self.rootStates}\n"
        # for content in self.transitions.values():
        for state in iterateBFS(self):
            # result += "  >"
            for e in self.transitions[state].values():
                note = " <<< LEAF TRANSITION >>>" if e.children == [] else ""
                result += f"  > {e.src} -- {e.info} --> {e.children}{note}\n"
        return result[:-1]  # trim the last '\n'

    def printTreeAut(self):
        print(f"Automaton '{self.name}' (port arity = {self.portArity})")
        print("=== Root States ===")
        print(str(self.rootStates))

        for stateName, content in self.transitions.items():
            print("=== State " + stateName + " ===")
            for edge in content.values():
                print(edge.src + " -- " + str(edge.info) + " --> " + str(edge.children))
        print("")

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Informative functions # - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    def getStates(self) -> list:
        result = []
        for stateName in self.rootStates:
            result.append(stateName)
        for stateName, edges in self.transitions.items():
            result.append(stateName)
            for data in edges.values():
                for i in data.children:
                    result.append(i)
        result = list(set(result))
        result.sort()
        return result

    # needed for feeding makePrefix() function
    # generates all edge symbols labeling the output edges from the TA
    def getOutputSymbols(self) -> list:
        outputEdgeList = []
        for edgeDict in self.transitions.values():
            for edge in edgeDict.values():
                if len(edge.children) == 0:
                    outputEdgeList.append(edge.info.label)
        return outputEdgeList

    # needed for feeding treeAutDeterminize() function
    # generates a dictionary of all output edge symbols
    # which correspond to a list of states,
    # from which the transitions with the specific symbol originate
    def getOutputEdges(self, inverse=False) -> dict:
        result = {}
        for edge in transitions(self):
            if len(edge.children) == 0:
                if inverse:
                    if edge.src not in result:
                        result[edge.src] = []
                    result[edge.src].append(edge.info.label)
                else:
                    if edge.info.label not in result:
                        result[edge.info.label] = []
                    result[edge.info.label].append(edge.src)
        for item in result.values():
            item.sort()
        return result

    # needed for bottom-up reachability -> used in useless state removal
    def getOutputStates(self) -> list:
        outputStateList = []
        for stateName, edges in self.transitions.items():
            for data in edges.values():
                if len(data.children) == 0:
                    outputStateList.append(stateName)
                    break
        return outputStateList

    def getSymbolArityDict(self) -> dict:
        symbolDict = {}
        for edges in self.transitions.values():
            for edge in edges.values():
                if edge.info.label not in symbolDict:
                    if edge.info.boxArray == []:
                        symbolDict[edge.info.label] = len(edge.children)
                    else:
                        symbolDict[edge.info.label] = len(edge.info.boxArray)
        return symbolDict

    def getPortArity(self) -> int:
        portArray = []
        for edgeDict in self.transitions.values():
            for edge in edgeDict.values():
                sym = edge.info.label
                if sym.startswith("Port") and sym not in portArray:
                    portArray.append(sym)
        return len(portArray)

    def isTDdeterministic(self) -> bool:
        for edgeDict in self.transitions.values():
            usedSymbols = []
            for edge in edgeDict.values():
                if edge.info.label not in usedSymbols:
                    usedSymbols.append(edge.info.label)
                else:
                    return False
        return True

    def getVariableOrder(self) -> list:
        vars = []
        for edgeDict in self.transitions.values():
            for edge in edgeDict.values():
                if edge.info.variable != "":
                    vars.append(edge.info.variable)
        vars.sort()
        return vars

    # Returns a dictionary of states, each of which has a list of variables,
    # that the state can "see" = i.e. the state has a transition with
    # this variable. e.g. {'q0': ['x1', 'x2'], 'q1': ['x5']}
    # if reverse==True: the dictionary is referenced by variables, and values
    # are lists of states. e.g. {'x1': ['q0'], 'x2': ['q0'], 'x5': ['q1']}
    def getVariablesVisibility(self, reverse=False) -> dict:
        result: dict[str, set] = {}
        if reverse is True:
            for edge in transitions(self):
                if edge.info.variable != "":
                    if edge.info.variable not in result:
                        result[edge.info.variable] = set()
                    result[edge.info.variable].add(edge.src)
            return result
        for edge in transitions(self):
            if edge.info.variable != "":
                if edge.src not in result:
                    result[edge.src] = set()
                result[edge.src].add(edge.info.variable)
        return result

    # Returns a list of all states that can be reached through 1 transition
    # from a specific state (only one directional)
    def reachableFrom(self, state: str) -> list:
        if state not in self.transitions:
            return []
        result = set()

        for edge in self.transitions[state].values():
            for child in edge.children:
                if child not in result:
                    result.add(child)
        return list(result)

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Modifying functions # - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # needed for union (and testing) - name collision resolving
    def renameState(self, oldName: str, newName: str):
        # renaming state in rootStates array (1st layer)
        if oldName in self.rootStates:
            self.rootStates.remove(oldName)
            self.rootStates.append(newName)

        if oldName not in self.transitions:
            return
        # supposing only one state with the oldName exists in treeAut
        # renaming state in the dictionary of states (1st layer)
        self.transitions[newName] = self.transitions.pop(oldName)

        # renaming name of the state inside transitions (2nd layer)
        for edge in transitions(self):
            if edge.src == oldName:
                edge.src = str(newName)
            # renaming state name inside the children array (3rd layer)
            for i in range(len(edge.children)):
                if edge.children[i] == oldName:
                    edge.children[i] = newName

    def removeState(self, state: str):
        if state in self.rootStates:
            self.rootStates.remove(state)

        if state in self.transitions:
            self.transitions.pop(state)

        for content in self.transitions.values():
            keysToDelete = []
            for key, edge in content.items():
                if state in edge.children:
                    keysToDelete.append(key)
            for key in keysToDelete:
                content.pop(key)

    # Creates a better readable state names for more clear images (DOT).
    # Useful after unfolding, determinization/normalization, etc.
    def reformatStates(self, prefix='q'):
        temp = {}
        i = 0
        for state in iterateBFS(self):
            if state not in temp:
                temp[state] = i
                i += 1

        for state, idx in temp.items():
            self.renameState(state, f"temporaryName{idx}")
        for idx in temp.values():
            self.renameState(f"temporaryName{idx}", f"{prefix}{idx}")

    def reformatKeys(self, prefix='k'):  # k as in 'key'
        counter: int = 1  # for no collisions
        for state in iterateBFS(self):
            swap = [key for key in self.transitions[state].keys()]
            for oldKey in swap:
                newKey = f"{prefix}{counter}"
                counter += 1
                self.transitions[state][newKey] = self.transitions[state].pop(oldKey)

    # # Shrinks the tree automaton
    # such that it only contain the states from list (reachable states)
    def shrinkTA(self, reachable: list):
        toDelete = [x for x in self.rootStates if x not in reachable]
        for stateName, content in self.transitions.items():
            if stateName not in reachable:
                toDelete.append(stateName)
            for edge in content.values():
                if edge.src not in reachable:
                    toDelete.append(edge.src)
                for i in edge.children:
                    if i not in reachable:
                        toDelete.append(i)

        for i in set(toDelete):
            self.removeState(i)

    # Calculates the smallest "hop" distance to the specified state from root
    # Works similarly to BFS but uses helping list to stop an iteration after
    # initial stack is exhausted and increases the distance counter
    def getRootDistance(self, state: str) -> int:
        distance = 0
        visited = set()  # cuts looping (BFS)
        workList = [i for i in self.rootStates]  # work list =>
        stateCount = len(self.getStates())

        while len(visited) != stateCount:
            nextIteration = []
            while workList != []:
                currentState = workList.pop(0)
                if currentState == state:
                    return distance
                visited.add(currentState)
                for i in self.reachableFrom(currentState):
                    if i not in visited:
                        nextIteration.append(i)
            workList = [i for i in nextIteration]
            distance += 1

        raise Exception(f"getRootDistance(): {state} not found in {self.name}")

    # Calculates all possible paths through the TA.
    # Path must begin with a root state and end with a leaf
    # note: based on DFS
    # result is a list of paths, path is a lists of states
    def calculatePaths(self) -> list:
        def preOrderDFS(state, path, result):
            path.append(state)
            if state in leaves:
                result.append(copy.copy(path))
            for i in self.reachableFrom(state):
                if i not in path:
                    preOrderDFS(i, path, result)
            path.pop()

        leaves = set(self.getOutputStates())
        result = []

        for root in self.rootStates:
            preOrderDFS(root, [], result)
        return result

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Building functions #  - - - - - - - - - - - - - - - - - - - - - - - - - -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # Prefix, suffix and infix creation was initially thought of as a means
    # of obtaining a partial order over the box alphabet.
    # Creating a total order over the box alphabet is necessary for canonical
    # form of folding/unfolding algorithms.
    

    def createPrefix(self, additionalOutputEdges):
        result = copy.deepcopy(self)

        result.name = f"prefix({self.name}, {additionalOutputEdges})"

        for stateName, content in result.transitions.items():
            tempDict = {}
            if stateName in self.rootStates:
                continue
            for symbol in additionalOutputEdges:
                tempString = str(stateName) + "-" + str(symbol) + "-()"
                tempDict[tempString] = TTransition(stateName, TEdge(symbol, [], ""), [])
            for tempName, tempEdge in tempDict.items():
                # checking for non-port output edge
                nonPortOutput = False
                for edge in content.values():
                    label = edge.info.label
                    if not label.startswith('Port') and len(edge.children) == 0:
                        nonPortOutput = True
                # skip adding non-port output edge
                # if another non-port output present
                if not tempEdge.info.label.startswith('Port') and nonPortOutput:
                    continue
                else:
                    content[tempName] = tempEdge
        result.portArity = result.getPortArity()
        return result

    def createSuffix(self):
        result = copy.deepcopy(self)
        result.name = f"suffix({result.name})"
        for stateName, edgeDict in result.transitions.items():
            check = True
            for edge in edgeDict.values():
                edgeLabel = edge.info.label
                if (edgeLabel.startswith("Port")):
                    check = False
                    break
            if check and stateName not in result.rootStates:
                result.rootStates.append(stateName)
        return result

    def createInfix(self, additionalOutputEdges):
        result = copy.deepcopy(self)
        ports = [sym for sym in additionalOutputEdges
                 if (sym.startswith("Port")
                     and sym not in result.getOutputSymbols())]
        result.name = f"infix({self.name}, {ports})"

        for state in result.getStates():
            # A) make all states rootstates
            if state in result.rootStates:
                continue
            result.rootStates.append(state)

            # B) add output ports from additionalOutputEdges to every state
            for i in ports:
                key = f"{state}-{i}->()"
                edge = [state, TEdge(i, [], ""), []]
                result.transitions[state][key] = edge
        result.portArity = result.getPortArity()
        return result


# ITERATORS

# custom iterator - yields only edges (no keys)
#  for cleaner code
def transitions(obj):
    dictObj = obj
    if isinstance(obj, TTreeAut):
        dictObj = obj.transitions

    for innerObj in dictObj.values():
        if isinstance(innerObj, dict):
            for edge in transitions(innerObj):
                yield edge
        else:
            yield innerObj


# Depth-first search iterator over states of a tree automaton
def iterateDFS(ta: TTreeAut):
    stack = [root for root in ta.rootStates]
    stack.reverse()
    visited = set()
    while stack:
        state = stack.pop()
        if state in visited:
            continue
        visited.add(state)
        yield state
        for edge in ta.transitions[state].values():
            for child in edge.children:
                if child not in visited:
                    stack.append(child)


# Breadth-first search iterator over states of a tree automaton
def iterateBFS(ta: TTreeAut):
    queue = [root for root in ta.rootStates]
    visited = set()
    while queue:
        state = queue.pop(0)
        if state in visited:
            continue
        visited.add(state)
        yield state
        for edge in ta.transitions[state].values():
            for child in edge.children:
                if child not in visited:
                    queue.append(child)
# End of file ta_classes.py
